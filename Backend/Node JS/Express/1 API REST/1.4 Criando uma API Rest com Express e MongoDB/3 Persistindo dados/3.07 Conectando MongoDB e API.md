# 3.07 Conectando MongoDB e API

Temos agora uma API e um banco MongoDB criado na nuvem. O próximo passo é conectar estas duas partes.

## Conectando o Banco MongoDB à API

Como funciona essa integração? Para utilizarmos qualquer tipo de banco de dados, seja SQL, NoSQL, normalmente precisamos realizar algumas instalações, como instalar os _drivers_ do banco, arquivos necessários, etc. A menos que estejamos usando _Docker_, o que não abordaremos neste curso.

No nosso caso, utilizamos o MongoDB Atlas, que cuidou da parte de instalação do banco, portanto não precisamos nos preocupar com isso. No entanto, ainda precisamos utilizar uma biblioteca que atue como intermediário entre o NodeJS e o MongoDB.

Pode surgir a pergunta: "Mas nós não já instalamos o MongoDB?" Sim, instalamos as dependências do banco. Porém, o que faremos agora é instalar outra biblioteca que será responsável por conversar com o MongoDB e realizar as operações de banco para nossa aplicação Node, assim como o _Express_ age como biblioteca responsável pelas rotas e pelas requisições.

O nome desta biblioteca já apareceu no navegador, é _Mongoose_. Existem outras bibliotecas que também desempenham esse papel de conectar bancos com APIs Node, mas vamos usar esta, pois é bem enxuta. Portanto, para esse momento em que o foco está na API, será mais tranquilo.

## Instalando o Mongoose

Como instalamos uma nova biblioteca? Vamos ao terminal, rodar `npm install`, ou `npm i` junto ao nome `mongoose`, e para instalar exatamente a versão que usada neste curso, escreveremos `mongoose@7.3.4`, que é a última versão no momento atual.

É uma biblioteca pequena, portanto, deve ser instalada rapidamente. Após esse processo, podemos voltar para nossa aplicação no VS Code e fazer a conexão usando a string de conexão abaixo trazida do MongoDB Atlas e que deixamos pronta no arquivo `app.js`.

```plaintext
// mongodb+srv://admin: <password>@cluster0.uvmwiwx.mongodb.net/?retryWrites=true&w=majority
```

Para isso, vamos acessar o explorador lateral esquerdo e criar, na pasta "src", uma nova pasta chamada "config" para armazenar os arquivos de conexão. Dentro desta, criaremos um arquivo chamado `dbConnect.js`.

No interior deste arquivo, utilizaremos a string de conexão. Vamos cortá-la do arquivo `app.js`, onde estava apenas guardada, e colá-la no `dbConnect.js` com "Ctrl+V".

Antes de mais nada, precisamos importar os métodos do _Mongoose_ que acabamos de instalar. Para isso, escrevemos o comando abaixo na primeira linha do arquivo.

```javascript
import mongoose from "mongoose";

// mongodb+srv://admin: <password>@cluster0.uvmwiwx.mongodb.net/?retryWrites=true&w=majority
```

Com isso, podemos utilizar os métodos da biblioteca. Entre o `import` e o comando do MongoDB, vamos utilizar `mongoose.connect()`, que recebe como parâmetro a nossa string de conexão, que deve estar entre aspas, pois se trata de uma string.

Para isso, vamos recortar essa string e colá-la entre os parênteses do método.

```javascript
import mongoose from "mongoose";

mongoose.connect("mongodb+srv://admin: <password>@cluster0.uvmwiwx.mongodb.net/?retryWrites=true&w=majority")
```

Se observarmos esta string de conexão, ela contém algumas informações. Uma delas é `admin:`, o nome de usuário que definimos quando criamos o banco, e a outra é `<password>`. No lugar de `<password>`, inseriremos o `admin123`. O Atlas não fornece a senha na string de conexão por segurança, portanto precisamos adicioná-la.

```javascript
import mongoose from "mongoose";

mongoose.connect("mongodb+srv://admin: admin123@cluster0.uvmwiwx.mongodb.net/?retryWrites=true&w=majority")
```

Adicionando essa informação no `dbConnect.js` _**ela irá para o GitHub**_. Se preferir, você pode omitir o arquivo `dbConnect.js`, do GitHub e adicionar ao `.gitignore`. Mas, por enquanto, vamos deixá-lo dessa forma para facilitar as configurações.

Existem _**formas de proteger esses dados**_, impedindo que eles sejam enviados para o GitHub ou para o repositório. Porém, vamos abordar isso posteriormente. Por enquanto, esses dados podem ficar como estão, pois vamos fazer nossa primeira conexão.

Na string de conexão, há o _cluster_ `cluster0`, que criamos. Temos também IDs criadas pelo MongoDB. Depois do trecho `mongodb.net/`, devemos adicionar `livraria`, que é o nome da nossa base de dados criada anteriormente. No final dessa instrução, temos que adicionar um ponto e vírgula.

```javascript
import mongoose from "mongoose";

mongoose.connect("mongodb+srv://admin: admin123@cluster0.uvmwiwx.mongodb.net/livraria?retryWrites=true&w=majority");
```

Para exportar tudo isso, acima dessa linha, vamos adicionar nosso método `connect()` dentro de uma função. Então, vamos criar uma `function`.

Uma parte interna dessa função servirá para conectar-se com o banco de dados. Portanto, ela deve ser uma **função assíncrona**.

Portanto, antes da palavra `function`, vamos passar a palavra-chave _**`async`**_. As operações assíncronas já foram abordadas nos cursos disponíveis como pré-requisitos para este. É essencial não esquecer dessa palavra-chave.

Vamos chamar essa função de `conectaNaDatabase()`. Não há necessidade de passar nenhum parâmetro nessa função, então simplesmente adicionaremos um par de parênteses e um par de chaves.

```javascript
import mongoose from "mongoose";

async function conectaNaDatabase() {

}

mongoose.connect("mongodb+srv://admin: admin123@cluster0.uvmwiwx.mongodb.net/livraria?retryWrites=true&w=majority");
```

Entre as chaves dessa função, a primeira linha será o nosso `mongoose connect()`, portanto, vamos movê-lo para este local. Abaixo dele, temos que retornar `return mongoose.connection`, que são métodos internos do `mongoose`. Ele vai se conectar com a _string_ de conexão e devolver um objeto com todas as informações que precisamos para nos conectar com o banco e realizar as operações.

Por fim, abaixo dessa função assíncrona, vamos realizar um `export default` da nossa função `conectaNaDatabase` para que possamos chamar ela em outros pontos da aplicação.

```javascript
async function conectaNaDatabase() {
  mongoose.connect("mongodb+srv://admin: admin123@cluster0.uvmwiwx.mongodb.net/livraria?retryWrites=true&w=majority");
    
  return mongoose.connection;
}

export default conectaNaDatabase;
```

Agora, podemos voltar para o nosso arquivo `app.js` e importar o nosso `conectaNaDatabase`. No topo do arquivo, abaixo de `import express`, vamos colocar `import conectaNaDatabase from`. Ao digitar esse trecho, o próprio VSCode completará o comando com o caminho `/.config/dbConnect` para nós, mas sem o `.js` no final. Não podemos esquecer de acrescentar esse `.js`, pois o VSCode, apesar de ser bastante proativo, pode não acrescentar isso.

```javascript
import express from "express";
import conectaNaDatabase from "./config/dbConnect.js";

// Código omitido
```

Faremos a conexão abaixo da linha da importação. Para isso, vamos criar uma constante chamada `conexao`. Ela receberá um `await`, lembrando que o `conectaNaDatabase()` é _async_, e por isso precisa de um `await` para funcionar corretamente. Assim, temos `await conectaNaDatabase()`.

```javascript
import express from "express";
import conectaNaDatabase from "./config/dbConnect.js";

const conexao = await conectaNaDatabase();

// Código omitido
```

Com isso, temos uma instância dessa conexão e os dados dela estarão salvos na nossa constante `conexao`. Para gerenciar essa conexão, vamos criar dois métodos abaixo da nossa constante `conexao`. O primeiro será `conexao.on()`.

Normalmente, em JavaScript, os métodos que têm o nome `on` estão relacionados a algum evento. Portanto, podemos esperar que o primeiro parâmetro desse método seja algum tipo de evento, como um evento de conexão aberta, um evento de conexão fechada ou um evento de erro.

O primeiro parâmetro desse método será uma _string_ com a palavra `error` entre aspas duplas, para que, antes de tratarmos o sucesso da conexão, possamos receber algum aviso caso a conexão não dê certo.

O segundo parâmetro será a _arrow function_ (função seta) `(erro) => {}`. Essa função vai receber um parâmetro chamado `erro` entre parênteses para capturar qualquer erro que seja recebido na nossa conexão.

Entre as chaves, informaremos um `console.error()` para verificar no terminal qual foi o erro ocorrido. Entre os parênteses deste, adicionaremos a string `erro de conexão` entre aspas duplas e seguida, adicionar vírgula e solicitar a impressão do conteúdo de `erro` no console.

```javascript
const conexao = await conectaNaDatabase();

conexao.on("error", (erro) => {
  console.error("erro de conexão", erro);
});
```

Portanto, a função `on` será acionada se o evento que ocorrer na conexão for um erro. Lembrando que `error` é uma _string_ que está em uma lista de eventos possíveis oriunda do `mongoose`.

Se ocorrer algum erro na conexão, este será recebido como parâmetro pela função e será impresso no `console.error()` com uma mensagem em português.

> É interessante usar mensagens em português nos consoles para facilitar a localização no terminal.

Em seguida, o erro será retornado. Este será um erro em inglês, com mais detalhes.

Abaixo de `conexao.on()`, precisamos adicionar mais um método, que será `conexao.once()`.

`conexao.once()` é um método que também aguarda por um evento específico. Neste caso, o evento será de conexão e o nome desse evento é `"open"`, que indica uma conexão aberta.

Portanto, o primeiro parâmetro será uma _string_ `"open"` e o segundo será uma _arrow function_ que não precisa receber qualquer parâmetro.

Entre as chaves desse método, ao invés de `console.error()`, vamos usar o `console.log("Conexão com o banco feita com sucesso")` para sinalizar que a conexão com o banco foi bem-sucedida..

```javascript
const conexao = await conectaNaDatabase();

conexao.on("error", (erro) => {
  console.error("erro de conexão", erro);
});

conexao.once("open", () => {
    console.log("Conexão com o banco feita com sucesso");
})
```

Agora, podemos retornar ao terminal para testar tudo o que foi criado e verificar se esta realmente se conectando ao banco de dados.

Lembre-se, para iniciar nosso servidor local, usamos o comando `npm run dev`.

```plaintext
npm run dev
```

Veremos a mensagem "servidor escutando", indicando que o servidor foi iniciado. Abaixo dela, será impressa a mensagem "Conexão com o banco feita com sucesso".

> servidor escutando!
> 
> Conexão com o banco feita com sucesso

Isso significa que nossa biblioteca Mongoose conseguiu se conectar à _string_ através do nosso método `dbConnect()` e passar essas informações para o `app.js`. Isso também significa que a conexão foi aberta sem erros.

Para confirmar se tudo está funcionando corretamente, podemos acessar o arquivo `dbConnect.js` e alterar qualquer informação na nossa _string_ de conexão. Por exemplo, vamos remover o "123" da senha, salvar as alterações e tentar novamente no terminal.

```javascript
async function conectaNaDatabase() {
  mongoose.connect("mongodb+srv://admin: admin@cluster0.uvmwiwx.mongodb.net/livraria?retryWrites=true&w=majority");
    
  return mongoose.connection;
}
```

Com isso, veremos no terminal que ocorreu um erro na conexão imediatamente após salvar o arquivo.

Se subirmos o terminal para o início das mensagens de erro, veremos que o comando lançou o método `conexao.on()` que havíamos definido, pois a mensagem em português "erro de conexão" foi exibida junto ao erro interno do MongoDB `autentication failed`, indicando que a autenticação falhou.

> erro de conexão MongoServer Error: bad auth: authentication failed

Em seguida, foi apresentado o _stack trace_, o qual não precisamos, uma vez que já sabemos o que ocorreu.

Voltando ao VS Code, vamos retornar à _string_ de conexão, reverter as alterações com "Ctrl+Z" e salvar novamente. Com isso, a mensagem de sucesso é reexibida no terminal e tudo volta a funcionar como o esperado.

> servidor escutando!
> 
> Conexão com o banco feita com sucesso

Devemos lembrar que o MongoDB é o nosso banco de dados e o Mongoose é a biblioteca que está criando essa interface entre o MongoDB e a nossa API. Ou seja, os métodos utilizados para conectá-los são internos da biblioteca do Mongoose – `mongoose.connect()` via `conexao`, `mongoose.on()` e `mongoose.once()`.

Portanto, qualquer conexão com diferentes tipos de bancos de dados dependerá dessa interface, ou seja, da biblioteca que estamos usando para fazer essa conexão.

A seguir, poderemos finalmente deixar de lado o array local de `const livros` e começar a salvar dados de verdade no banco de dados.