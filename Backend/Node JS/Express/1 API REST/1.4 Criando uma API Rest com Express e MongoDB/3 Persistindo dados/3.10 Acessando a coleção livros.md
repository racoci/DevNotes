# 3.10 Acessando a coleção livros

Agora que já temos o nosso modelo de livro criado, podemos alterar o arquivo `app.js` para que a rota se conecte com o _MongoDB_, ao invés de se conectar com o arranjo.

## Conectando a Rota ao MongoDB

Vamos iniciar adicionando uma importação no topo do arquivo para importar o modelo `livro`, informando o caminho do arquivo `Livro.js` que está localizado dentro da pasta `models`.

```javascript
import express from "express";
import conectaNaDatabase from "./config/dbConnect.js";
import livro from "./models/Livro.js";|
```

Não precisamos mais do _array_ `const livros` que utilizávamos anteriormente, então vamos excluí-lo. Também não utilizaremos mais a função `buscaLivro(id)` que estava relacionada a esse _array_, então também a excluiremos.

Agora, vamos refatorar a primeira rota, ou seja, o `get` que recolhe livros será modificado para retornar os livros que inserimos no banco.

Vamos acessar o segundo método `app.get()` de cima para baixo, que trabalha com a rota `"/livros"`. Vamos manter o trecho `app.get("/livros", (req, res) =>` como está, pois está sendo manipulado pelo Express. Já entre as chaves do método, chamaremos o modelo.

Como mencionado anteriormente, o modelo será responsável por definir como nós poderemos nos conectar e interagir com o banco de dados.

Entre as chaves do método, acima do `res.status()`, vamos criar uma _const_ chamada `listaLivros`, que armazenará todos os livros que retornamos do banco. Ela será igual a um `await livro.find()`, onde `livro` é o modelo que importamos e `find()` é uma função que nesse caso receberá apenas um objeto vazio (`{}`).

```javascript
app.get("/livros", (req, res) => {
    const listaLivros = await livro.find({});
    res.status (200).json (livros);
});
```

Na linha de `res.status()`, a resposta que precisamos sempre enviar será a mesma, com status `200`, mas o JSON agora retornará `listaLivros` ao invés do array `livros`.

```csharp
app.get("/livros", async (req, res) => {
  const listaLivros = await livro.find();
  res.status(200).json(listaLivros);
});
```

Devemos lembrar que, ao adicionar um `await` dentro de uma função, ela deverá se conectar com um `async` do lado de fora para que a função assíncrona funcione. Neste caso, adicionaremos o `async` à esquerda do `(req, res)`, pois ele se referirá à função _callback_ (função passada a outra como argumento) chamada dentro de `app.get()`.

Nesse contexto, o `.find()` é um método do _Mongoose_ que vai se conectar com o banco de dados _MongoDB_ no Atlas que fará uma busca (_find_) e como nenhuma especificação foi passada, buscará tudo o que encontrar na coleção `livros`.

Vale lembrar que a coleção livros também está sendo passada dentro do modelo `Livros`, como mencionado anteriormente, e este modelo é responsável pela conexão com o banco e determina o que podemos fazer com ele.

Vamos examinar se tudo está funcionando corretamente. Para isso, vamos ao terminal para verificar se não há nenhum erro. Tudo parece estar bem, pois a conexão foi feita com sucesso.

Vamos ao _Postman_ para realizar um GET em `/livros`. O endereço é o mesmo, "[http://localhost:3000/livros](http://localhost:3000/livros)" o método é o mesmo `get`, e ele não precisará receber nada na requisição, somente na resposta. Portanto, vamos clicar no botão "Send", no topo da página, à direita do endereço.

 
```json
{
    "_id":"64c2a45ad5a0d7f958add9e0",
    "titulo": "O Senhor dos Anéis",
    "editora": "Classicos",
    "preco": 10,
    "paginas": 200
}
```

Na guia "Body", veremos que resultado está correto. Agora, ao invés de retornar o _array_, o `get` em `localhost:3000/livros` retornou exatamente o que inserimos manualmente no Atlas, no qual temos um _id_ especificado pelo MongoDB.

Por enquanto, os métodos não funcionarão, pois ainda estão ligados ao _array_ excluído. Mas não tem problema, pois vamos analisar esse caso posteriormente.

Antes de finalizar, temos um pequeno problema a abordar no VS Code. Como mencionado antes, a senha do nosso banco de dados está explícita no código e isso não pode ser carregado para o GitHub. Vamos refatorar o código e resolver isso agora?

Para isso, vamos acessar o arquivo `dbConnect.js`, no qual utilizaremos um recurso chamado _**variável de ambiente**_.

## Refatorando com Dotenv e Variáveis de Ambiente

As variáveis de ambiente são utilizadas para separar informações variáveis sensíveis, como senhas e strings de conexão. Esses dados não podem ser compartilhados nem acessados livremente através de um repositório no GitHub.

Para resolver o problema em um projeto Node, primeiramente, vamos acessar o terminal e interromper a execução do nosso servidor. Em seguida, vamos executar o comando abaixo e fazer a instalação da biblioteca _Dotenv_, utilizada para gerenciar as variáveis de ambiente.

```plaintext
npm instal dotenv
```

Essa biblioteca é de dimensão compacta e pode ser utilizada em sua última versão.

Após a sua instalação, como o utilizamos?

Voltando ao VS Code, criaremos um arquivo na pasta "src", raiz do projeto, que se chamará `.env`, com um ponto no início e sem `.js`, da mesma forma que o `.gitignore`.

No interior desse arquivo, estabelecemos as variáveis de ambiente, ou seja, as variáveis que representam todas as informações sensíveis que não podemos compartilhar. No nosso caso, a string de conexão.

Vamos voltar para o arquivo `dbconnect.js` e recortar a string de conexão inteira, removendo-a de `mongoose.connect()`.

Voltando ao interior do arquivo `.env`, vamos criar o nome dessa variável. O padrão é escrever tudo em letras maiúsculas e com _underline_ (`_`), portanto, criaremos a `DB_CONNECTION_STRING`. Ela receberá a string de conexão que vamos colar, sem a necessidade das aspas duplas.

```plaintext
DB_CONNECTION_STRING=mongodb+srv://admin: admin123@cluster0.uvmwiwx.mongodb.net/livraria?retryWrites=true&w=majority
```

Após salvar o `.env`, vamos fechá-lo e abrir o arquivo `.gitignore`, pois é importante lembrar de incluir nele o `.env` no mesmo, abaixo de `node_modules`. Caso contrário, este arquivo acabará sendo enviado para o repositório do GitHub, invalidando o propósito de sua criação.

```plaintext
node_modules
.env
```

Após essas etapas, precisamos iniciar o `.env` no ponto mais externo da aplicação, ou seja, o primeiro a ser acessado. No nosso caso, o ponto mais externo da aplicação é o `server.js`, que está na pasta raiz "src". No início desse arquivo, acima da linha de importação do `app`, vamos importar o `.env` utilizando o comando abaixo.

```javascript
import "dotenv/config".
```

Essa linha é suficiente para importar e iniciar o `.env` em nossa aplicação.

Vamos voltar ao `dbConnect.js` e acessar o entremeio dos parênteses do `mongoose.connect()`. Vamos substituir o seu conteúdo (que antes era a string de conexão) pela variável de ambiente. Para fazer isso, iremos nos referir a essa variável por `process.env.DB_CONNECTION_STRING`. O restante do código continuará igual.

```csharp
async function conectaNaDatabase() {
    mongoose.connect(process.env.DB_CONNECTION_STRING);
    return mongoose.connection;
};
```

Desse modo, protegemos as informações sensíveis usando variáveis de ambiente.

Essa variável ficará armazenada apenas localmente em nosso computador. Portanto, ela não será enviada para o GitHub e não precisamos mais nos preocupar com a string de conexão do banco sendo compartilhada.

Tudo pronto! Agora podemos enviar o projeto para o GitHub se quisermos. Já está tudo associado: o _Mongo Atlas_, o _MongoDB_ através do _Mongoose_ com a nossa API e o _NodeJS_.

A seguir, poderemos voltar à nossa aplicação e fazer os outros métodos - GET, POST, PUT e DELETE - funcionarem corretamente com o banco. Vamos lá!