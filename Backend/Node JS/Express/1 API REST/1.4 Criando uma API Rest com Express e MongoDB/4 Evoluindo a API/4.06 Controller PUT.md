# 4.06 Controller PUT

Continuando então a refatoração, verificamos que fizemos o GET para todos os livros e o POST para cadastrar um livro. Agora, precisamos lidar com funcionalidades para pegar um livro, atualizar um livro e deletar um livro.

Vamos começar criando uma função para listar um único livro. No nosso controller, vamos criar um método para pegar um livro por ID.

Porém, antes de continuar, vamos realizar uma pequena refatoração no primeiro método que criamos - o de listar livros. Vamos adicionar um bloco _try-catch_ no método `listarLivros`.

No bloco _try_, colocamos todo o código que potencialmente pode gerar um erro e lidamos com as exceções. Assim, dentro do _try_, vamos inserir as duas linhas que foram criadas anteriormente para listar os livros.

Em seguida, dentro do bloco _catch_, criamos uma resposta genérica para os erros.

```javascript
  static async listarLivros (req, res) {
    try {
      const listaLivros = await livro.find({});
      res.status(200).json(listaLivros);
    } catch (erro) {
      res.status(500).json({ message: `${erro.message} - falha na requisição` });
    }
  };
```

Agora, que fizemos essa refatoração, vamos continuar criando um método para pegar um único livro.

No _controller_, abaixo do método `listaLivros()`, vamos copiar o método recém-refatorado e modificar alguns aspectos para que ele passe a buscar um livro específico pelo `ID`.

Como vamos pegar um livro por id, já sabemos que devemos ter esse id referenciado na nossa rota. Como fizemos isso lá no `app.js`? Nós buscamos um livro recebido via `req.params.id`. Vamos manter isso igual, porque essa parte de pegar requisições e manejar pelo Express também vai continuar igual.

Em vez de usar o método `find()`, usaremos `findById()` que recebe o id que está vindo dos parâmetros. Então vamos criar uma `const id` onde guardaremos o resultado de `req.params.id`.

Podemos passar o id para dentro do `livro.findById()`. É o id do registro que ele vai pegar lá no banco. Após pegar esse id, ele vai salvar esse id dentro da variável `livroEncontrado`.

Na resposta continua sendo status 200, mas agora o JSON vai mandar apenas o livro encontrado.

```javascript
  static async listarLivroPorId (req, res) {
    try {
      const id = req.params.id;
      const livroEncontrado = await livro.findById(id);
      res.status(200).json(livroEncontrado);
    } catch (erro) {
      res.status(500).json({ message: `${erro.message} - falha na requisição do livro` });
    }
  };
```

Por enquanto, estamos usando mensagens de erro genéricas. No futuro, vamos avançar para usar formas mais sofisticadas de manejar e tratar erros.

Já temos um método para captar um livro do banco e mandar para nós via requisição.

Agora, podemos fazer a parte de atualizar livro, que será bem parecida com o que fizemos anteriormente. A atualização será semelhante à obtenção do livro por ID, mas terá uma pequena diferença. Vamos criar então este método.

Primeiramente, vou copiar o método `listarLivroPorId`, pois a atualização de um livro também necessitará do ID do livro (ou seja, `req.params.id`). Vou colar esse método ao final da nossa classe, abaixo do método `cadastrarLivro`. Em vez de chamar esse método de `listarLivroPorId`, vou nomeá-lo `atualizarLivro`. Ele também recebe `req` e `res`, possui o bloco `try` e precisa do ID do livro, que chega pelos parâmetros da rota.

No entanto, o método para atualizar o livro não será mais `findById`. Vou remover a parte `const livroEncontrado` e manter apenas a chamada da função, que será `await livro.`. Qual será o método aqui? O nome desse método será `findByIdAndUpdate`. Este método vem do _Mongoose_, que cuida internamente de toda essa operação.

Mas qual a diferença? O que precisamos para atualizar um livro? Precisamos de duas informações: a primeira é o identificador único para identificar e alterar o livro correto e a segunda são os dados atualizados do livro. E essa informação, assim como fizemos anteriormente, virá de `req.body`. Ou seja, nossa requisição de atualização precisará passar duas informações: o ID do livro, que vem do parâmetro da rota, e os novos dados deste livro, ou seja, o objeto com o livro atualizado que vem de `req.body`.

E como sabemos que a função `findByIdAndUpdate` precisa receber esses dois parâmetros nessa ordem? Isso vem do próprio _Mongoose_. A documentação do _Mongoose_ nos esclarece como esta função funciona. Vamos precisar passar o `ID` e o `update` (ou seja, na mesma ordem que passamos aqui: o ID do objeto que será atualizado e o update deste objeto).

E o que retornaremos na resposta? Cada método tem um retorno específico. No caso da criação de um objeto, ele retorna o objeto criado, etc. Nesse caso, ele não retorna o objeto criado, pois o próprio método cuida disso. Por isso, removi a parte de salvar o retorno de `Livro.findUpdate`. Estamos simplesmente chamando a função aqui com `await`.

Na nossa resposta, mantemos `res.status(200)`, mas agora na mensagem, dentro de JSON, podemos simplesmente passar um objeto com `message`, e nessa `message` pode ser apenas uma string com "Livro atualizado".

Aqui no `catch`, ficará bem semelhante, só precisaremos trocar o texto de "Falha na requisição do livro" para "Falha na atualização". E a parte de `atualizarLivro`, `cadastrarLivro`, `listarTodosOsLivros` e `listarLivroPorId` parece estar tudo correto.

```csharp
  static async atualizarLivro (req, res) {
    try {
      const id = req.params.id;
      await livro.findByIdAndUpdate(id, req.body);
      res.status(200).json({ message: "livro atualizado" });
    } catch (erro) {
      res.status(500).json({ message: `${erro.message} - falha na atualização` });
    }
  };
```

A única coisa que não podemos esquecer de fazer é, no arquivo `app`, remover o que não estamos mais utilizando. Portanto, não estamos mais utilizando nenhum desses `app.get`, `app.post`, nem `app.put`. Vou aproveitar para remover também o `app.delete`, embora eu deixe um ponto de referência do que foi feito antes. Mas os outros, não estamos mais usando. Na nossa parte de rotas, no arquivo `livrosRoutes`, precisamos atualizar com todas essas rotas que criamos:

```javascript
import express from "express";
import LivroController from "../controllers/livroController.js";

const routes = express.Router();

routes.get("/livros", LivroController.listarLivros);
routes.get("/livros/:id", LivroController.listarLivroPorId);
routes.post("/livros", LivroController.cadastrarLivro);
routes.put("/livros/:id", LivroController.atualizarLivro);

export default routes;
```

Agora, as rotas estão atualizadas. Já sabemos qual função será chamada no momento em que uma requisição for feita para cada uma dessas rotas, baseando-se no método. É interessante ressaltar que a rota é a mesma, mas os métodos são diferentes. Assim, ao fazer uma chamada para /livros com `GET`, uma função será chamada. Fazendo uma chamada para a mesma rota /livros, mas com outro método, como `POST`, outra função correspondente será chamada. Ou seja, a rota permanece a mesma, e apenas o método muda.

Chegamos então à última parte, que sabemos ser a remoção de um registro. Vamos fazer o seguinte: vamos, em seguida, deletar, completar nosso CRUD e fazer todo o teste de uma só vez. Vamos lá.