Agora vamos finalizar nosso CRUD básico. Neste momento, não há surpresas, vamos criar o último método do _controller_, que é para excluir um livro.

Se quiser, você pode pausar o vídeo agora e tentar criar o método. Verifique se tudo está correto e depois continue assistindo. Então vamos lá.

No final do arquivo, vamos criar o último método. Posso até copiar o método anterior, de atualização de livro, pois a exclusão será muito similar. Assim como para atualizar um livro, para excluí-lo também preciso de sua informação de ID, que já estamos pegando aqui.

O último método será chamado de `excluirLivro`. Aqui também obtemos `req.params.id` e o salvamos em uma variável chamada `id`. Se preferir, pode passar `req.params.id` diretamente dentro do método do Mongoose, mas preferi deixar um pouco mais explícito em nosso código.

Com `const id`, estamos armazenando nosso `id` que recebeu pelo parâmetro. Agora o método não será mais o `findByIdAndUpdate`, e sim o `findByIdAndDelete`, que é um método do Mongoose.

Como estamos apenas excluindo, não existe o segundo parâmetro anterior, que passava o `req.body`. Ele só receberá um parâmetro que é o `id` que trouxemos lá da requisição.

O retorno, a resposta da requisição, permanece a mesma, status 200, lembrando que pode ser tanto 200 quanto 204. A mensagem será "Livro excluído com sucesso".

O lançamento da exceção também segue o mesmo modelo, só que ao invés de "Falha na atualização", podemos escrever que houve uma "Falha na exclusão", caso algo ocorra aqui e nossa operação de exclusão não dê certo.

Aqui, sem novidades, não retornarei nada com o meu `findByIdAndDelete`, é só executar a mesma função.

```csharp
  static async excluirLivro (req, res) {
    try {
      const id = req.params.id;
      await livro.findByIdAndDelete(id);
      res.status(200).json({ message: "livro excluído com sucesso" });
    } catch (erro) {
      res.status(500).json({ message: `${erro.message} - falha na exclusão` });
    }
  };
```

A última coisa que devemos fazer é ir no arquivo `livrosRoutes.js` e adicionar a última rota:

```go
routes.delete("/livros/:id", LivroController.excluirLivro);
```

É igual ao que já estávamos usando anteriormente, também recebe `livros`, também recebe um `id` de livro e o método que será chamado quando a requisição atingir essa rota será `excluirLivro`.

Agora o CRUD de `Livro` está completo, tem todos os métodos, está associado a um banco de dados, agora o que precisamos fazer é testar o processo lá no Postman.

Vamos verificar o servidor, no terminal, o servidor está de pé, a conexão está conectada, e agora vamos para o Postman vou fazer o teste do fluxo completo.

Primeiro, vamos testar `/livros` para ver se o nosso "Senhor dos Anéis", que já estava no banco, aparece corretamente. Tendo sucesso no teste, vou copiar o `id` e passar aqui para fazer a busca por `id`.

Então, `localhost:3000/livros/id`, e veremos que nosso objeto com o livro retornado lá do banco. Agora falta testar os outros métodos.

Vamos abrir uma nova aba para testar a operação de POST. Lembrando, ela não tem `id`, mas precisamos passar um corpo da requisição com as informações que queremos inserir no banco.

vamos selecionar a opção "Body" e, no menu "Text", a opção "JSON". Para facilitar, podemos voltar à aba do GET e vou copiar o objeto livro que foi retornado a fim de apenas alterarmos algumas informações, evitando ter que digitar tanto.

Não passamos o `id` ao criar um novo registro, a geração do `id` é sempre responsabilidade do banco.

O título do livro será "O Hobbit", publicado pela editora Clássicos, com o preço estabelecido em 6 reais, tornando-o bem acessível. Esse é um livro mais fino do que "O Senhor dos Anéis", por isso vou percorrer apenas suas 100 páginas aqui.

> POST [http://localhost:3000/livros/](http://localhost:3000/livros/)

```json
"titulo": "O Hobbit",
"editora": "Classicos",
"preco": "6",
"páginas": "100"
```

Nosso corpo de mensagem está aqui. Após clicar em "Send, recebemos o retorno com status "201 created", o que era esperado, e o retorno veio corretamente.

```json
{
    "message": "criado com sucesso",
        "livro":  {
        	"titulo": "O Hobbit",
        	"editora": "Classicos",
        	"preco": "6",
        	"páginas": "100",
                "_id": "64c2cd91bcd4d28e0209ed76"
        }
}
```

Recuperou-se o objeto que nós solicitamos, com a mensagem "criado com sucesso". Em seguida, uma propriedade "livro" com o livro que foi criado. Isto é similar ao que vimos quando revisamos o método `cadastrarLivro` do nosso `LivroController`.

No caso deste método, ele retorna exatamente o que nós pedimos: uma mensagem "criado com sucesso" e uma propriedade "livro" que tem como valor um novo livro. `novoLivro` é a constante onde salvamos o retorno do método `create()`.

Este método, por padrão, sempre retorna o objeto que foi criado. Contudo, nem todo método funciona assim. Como já discutimos antes, métodos retornam coisas diferentes, dados diferentes ou, às vezes, não retorna nada. Neste caso, ele retornou corretamente o objeto criado.

Agora, o que falta testarmos? O método PUT. Vamos usar como base o "O Hobbit", que já foi criado aqui no POST.

Podemos copiar o id dele e alterar o método da nossa requisição para PUT. Em `/livros`, acrescento o id do "O Hobbit" que acabamos de criar.

Lembre-se de que, para fazer uma atualização, devemos passar, via corpo da requisição, o que queremos alterar. Por exemplo, quero mudar o preço. O preço não é de seis reais, mas sim cinco reais.

> PUT [http://localhost:3000/livros/64c2cd91bcd4d28e0209ed76](http://localhost:3000/livros/64c2cd91bcd4d28e0209ed76)

```json
{
    "preco": 5
}
```

Depois de passar todas as alterações necessárias, clicaremos no botão "Send".

O retorno informa "livro atualizado", mas precisamos confirmar se tudo ocorreu como esperado.

Podemos fazer essa confirmação na mesma aba, trocando de PUT para GET. Então, agora vou fazer um GET em `/livros/` mais o id do livro que acabamos de atualizar.

Após pressionar o botão "Send", o retorno confirma que nosso "O Hobbit" está com o preço atualizado. Portanto, PUT está correto.

Aproveitando, vamos usar o id do livro que acabamos de criar para deletá-lo. Na mesma aba, na mesma requisição, só precisamos trocar o método para DELETE em `/livros/` mais o id que queremos deletar. Após clicar em "Send", temos a confirmação de "livro excluído com sucesso".

Para confirmar que de fato ele foi excluído, trocamos para GET em `/livros/` para ver se "O Hobbit" realmente desapareceu.

Após realizar o GET em `localhost 3000/livros`, o único livro que resta é "O Senhor dos Anéis".

Portanto, nosso fluxo CRUD (Create, Read, Update, Delete) está completo. A partir de agora, evoluiremos essa API cada vez mais, com erros, autenticação, paginação, outras validações e muito mais. Alguns desses conceitos serão abordados nas próximas aulas, enquanto outros serão vistos em outros cursos de formação. Vamos em frente!