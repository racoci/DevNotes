Nesse momento da nossa aplicação, continuar desenvolvendo significa que precisamos parar um pouco e organizar nossa estrutura para que a aplicação possa crescer de forma organizada.

Olhando para o arquivo `app.js`, percebemos que ele já está bem comprido e fazendo muita coisa. Todas as rotas estão dentro dele e, neste momento, você deve ter percebido que isso está um pouco desorganizado.

É difícil expandir essa aplicação sem acentuar ainda mais a desorganização se continuarmos desta forma. Torna-se complicado alterar coisas no futuro, encontrar quais partes da aplicação estão realizando determinadas tarefas, e assim por diante. Portanto, nosso foco aqui é aliviar um pouco a responsabilidade do `app.js` e deixá-lo responsável apenas pela criação da nossa aplicação com o Express.

A primeira coisa que faremos é focar nas rotas, separar nossas rotas e extrair nossos `apps.get` e `apps.post` do `app.js`. No entanto, antes de se concentrar nas rotas em si, nós vamos organizar um pouco melhor a parte de requisição e resposta, ou seja, a parte que recebe a requisição e monta as respostas via Express.

Para isso, nós vamos utilizar uma estrutura que chamamos de _controller_ (controladores).

Antes de aprofundarmos no que são controladores, vamos observar um pouco na prática.

Na nossa pasta "src", vou criar uma nova pasta chamada "controllers" e, dentro dela, vou criar nosso primeiro _controller_ que será `livroController.js`.

Dentro do _controller_, nós centralizaremos toda a lógica que está relacionada às ações que podem ser feitas em um livro, ou seja, o que as rotas vão chamar para executar as operações e o manuseio das requisições e respostas correspondentes.

No `livroController.js`, vamos criar nosso primeiro _controller_.

Como ele fará uma interface entre as requisições e o que acontecerá em cada requisição, significará que vamos transferir nossa importação do modelo `Livro` para cá. Começando na primeira linha, realizaremos a importação do nosso modelo `Livro`.

```javascript
import livro from "../models/Livro.js";
```

Não se pode esquecer do `.js`, já mencionei isso várias vezes.

O _controller_ será uma classe com vários métodos. Vou utilizar a palavra-chave `class` para criar o `LivroController`. Lembrando que as classes sempre começam com letra maiúscula. A classe em si não recebe parâmetros, apenas abre e fecha chaves. E já vamos exportar essa classe. Portanto, no final do arquivo, `export default LivroController`:

```javascript
import livro from "../models/Livro.js";

class LivroController {

};

export default LivroController;
```

Agora, temos uma classe que terá vários métodos, um para cada coisa, para cada operação que conseguiremos fazer no `Livro`. Incluindo o recebimento e manuseio das requisições e respostas. Vamos começar criando o primeiro método da nossa classe `LivroController`.

Criaremos um método para listar livros. Nosso primeiro `get`, o `getAll`, que nós chamamos. Criarei com a palavra-chave `static` e a palavra-chave `async`. Portanto, `static async`, chamarei esse método de `ListarLivros`. Agora sim, ele vai receber dois parâmetros.

Quais serão esses parâmetros? Como o _controller_ vai manusear as requisições e as respostas, esses serão os parâmetros que ele vai receber. Portanto, `req`, `res`, e então vou abrir e fechar chaves. Isso aqui não é uma _arrow function_.

```javascript
import livro from "../models/Livro.js";

class LivroController {
 
    static async ListarLivros (req, res) {
    
    }

};

export default LivroController;
```

E o que é `static async`? _Async_ nós já sabemos, porque esse método terá que se conectar com o banco, então será uma operação assíncrona. O _static_ é uma palavra-chave que usamos quando queremos usar métodos de uma classe sem ter que, antes, instanciar essa classe. Ou seja, eu não quero criar um `new LivroController` e só, então, conseguir usar os métodos. Eu quero poder chamar eles de forma estática. Portanto, é para isso que essa palavra-chave está aí.

Vamos ver esse método sendo chamado em breve, e tudo fará mais sentido.

Então, o que o método `ListarLivros()` faz? Vamos criar aqui uma constante `listaLivros`... Na verdade, não precisamos criar esta constante, porque o que vai acontecer aqui é exatamente o que ocorre no arquivo `app.js`, dentro do nosso método `getLivros`.

Portanto, vamos acessar o `app.js` e copiar as duas linhas que representam a implementação da função.

```csharp
const listaLivros = await livro.find({});
res.status(200).json(listaLivros);
```

Por enquanto, podemos comentar nosso método `app.get` que está no `app.js`. Vamos voltar ao arquivo `livroController` e colar essas duas linhas do`const listaLivros`. Nosso código vai ficar assim:

```javascript
import livro from "../models/Livro.js";

class LivroController {
 
    static async ListarLivros (req, res) {
      const listaLivros = await livro.find({});
    res.status(200).json(listaLivros);
    }

};

export default LivroController;
```

Agora, começamos a reorganizar, estamos removendo algumas implementações do arquivo `app.js` e separando isso em um controlador separado. E por fim, podemos focar na parte restante do `app.get`, que é criar as rotas que também serão removidas do `app.js`.

Também vamos separar as rotas, criando diretórios para elas. Dentro deste diretório, vou criar um arquivo que chamaremos de `livrosRoutes`, onde "_routes_" é a tradução para "rotas" em inglês.

Aqui, começamos a organizar a parte das rotas, responsabilidade que também é do Express.

No arquivo `livrosRoutes`, vou importar o `express`. E já que a rota precisa se conectar ao controlador, vou importar também nosso controlador.

```javascript
import express from "express";
import LivroController from "../controllers/livroController.js";
```

Agora, podemos começar a definir as rotas. O Express tem um método específico para lidar com as rotas, e vamos chamá-lo agora. Então, vamos criar uma constante que será chamada `routes`, igual a `express.Router()`.

Abaixo, vamos chamar o `routes` que criamos e chamar o método `.get()`. Agora, vamos abrir e fechar parênteses e podemos passar para ele a nossa rota, da mesma maneira que estávamos fazendo no arquivo `app.js`. Assim, o primeiro parâmetro será uma string `/livros`. Se voltarmos ao `app.js`, o segundo parâmetro era uma função que estava sendo chamada diretamente aqui, uma função _callback_.

Entretanto, agora, já temos essa função definida dentro do `livroController`. Dessa forma, no nosso `livrosRoutes`, o primeiro parâmetro fica como está, e o segundo parâmetro, ao invés da função _callback_, será agora `LivroController.listarLivros`, sem abrir e fechar parênteses, pois só estamos passando aqui uma referência ao método que deve ser chamado.

```javascript
import express from "express";
import LivroController from "../controllers/livroController.js";

const routes = express.Router();

routes.get("/livros", LivroController.listarLivros);
```

Portanto, agora nós podemos regressar ao `app.js` e excluir o seguinte trecho:

```csharp
app.get("/livros", async (req, res) => {
  const listaLivros = await livro.find({});
  res.status(200).json(listaLivros);
});
```

Porque já separamos as duas partes: a parte do controlador, que administra a requisição e a resposta, e a parte das rotas, que é o método `.get` e a função que é executada quando essa rota é chamada. Essencialmente é o que o nosso `routes.get` está fazendo através do Express.

## Conclusão

Sabemos que uma aplicação pode ter inúmeras rotas, portanto, apenas para `Livros` já criamos cinco rotas diferentes. Além disso, vamos continuar criando rotas e organizando essas partes para que as rotas sejam chamadas de uma maneira mais eficiente pela aplicação. Em seguida, veremos como isto funcionará!