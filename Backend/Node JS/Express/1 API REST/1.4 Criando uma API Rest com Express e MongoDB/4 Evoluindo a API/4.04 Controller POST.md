# 4.04 Controller POST
Agora que criamos o primeiro método no nosso controlador, nosso `LivroController`, vamos continuar aprimorando e criando mais métodos para tirar do `app.js` toda a parte de rotas e a parte de requisição e resposta, que é tudo para o Express resolver junto com o Mongoose.

Vamos trabalhar aqui no nosso `app.post`, que ainda está no `app.js`. Primeiramente, no `LivroController`, vamos adicionar um método para realizar os cadastros de livros.

Vamos criar um método `static async` que vou chamar de `cadastrarLivro`. Esse método, que cadastra um livro por vez, também vai receber requisição e resposta do Express.

```csharp
  static async cadastrarLivro (req, res) {

  }
```

No `app.js` podemos copiar apenas a linha de resposta `res.status` do `app.post`, pois a linha anterior `livros.push` ainda faz referência ao _array_ que nem existe mais.

Dentro do `LivroController`, antes de implementar toda a lógica interna de ir no banco de dados, buscar um livro, etc., faremos o seguinte: dentro do método `cadastrarLivro`, vamos criar um bloco _try/catch_.

```csharp
  static async cadastrarLivro (req, res) {
     try {
    
     } catch (erro)

  }
```

Pequena observação sobre o `try-catch`: essa estrutura é utilizada quando queremos fazer manejo de erros e sucessos. Vou compartilhar mais material sobre esse tópico nas atividades, e durante o preenchimento do bloco, entenderemos melhor sua aplicação dentro do nosso método.

Dentro do `try`, vamos inserir a resposta que copiamos do `app.js`, que é o `res.status(201).send()`. No entanto, antes disso, precisamos entender como o Mongoose vai realizar o processo de post, de cadastrar um livro.

Vamos criar uma `const novoLivro` igual a await `livro.create()`. `livro` é o que está chamando o modelo do Mongoose e `create()` é o nome do método que o Mongoose utiliza para criar um registro no banco.

Como passamos o objeto que será criado para dentro do `create()`? Passaremos através da requisição `req.body`. O Express continua trazendo a requisição para nós, dentro da requisição tem a propriedade body e é essa propriedade que vamos passar pra dentro do `create()` que está fazendo toda interação com o banco.

O `res.status(201)` continua, mas agora precisamos substituir o `.send` por `.json` e podemos mandar uma resposta um pouco mais elaborada. Vamos mandar uma resposta mais clara do que está acontecendo.

Vamos abrir chaves para criar um objeto, a primeira propriedade será `message`, em seguida passaremos a string "criado com sucesso" e passaremos a propriedade `livro: novoLivro`. Porque `novoLivro` será o retorno do método `create()`. O Mongoose vai chamar o `create()` e esse método, por definição, vai retornar o objeto que foi criado, será guardado em `novoLivro`.

No `catch`, vamos criar uma resposta de erro mais genérica, vai ter um `res.status` com código `500`, que é um código HTTP para erros internos no servidor, ou seja, indica que houve algum problema genérico que não é do cliente, mas do servidor. Isso é seguido por um `.json` que retorna um objeto com uma mensagem de erro estruturada.

Neste momento, criarei uma _template string_ usando acento grave. Vou digitar cifrão e chaves e, nesta mensagem de erro, inserir a propriedade `erro.message`. E a mensagem será "falha ao cadastrar livro".

```javascript
  static async cadastrarLivro (req, res) {
    try {
      const novoLivro = await livro.create(req.body);
      res.status(201).json({ message: "criado com sucesso", livro: novoLivro });
    } catch (erro) {
      res.status(500).json({ message: `${erro.message} - falha ao cadastrar livro` });
    }
  }
```

Mas, você deve estar se perguntando, o que faz o `erro.message`?

O bloco `catch` será executado se qualquer parte do código dentro do `try` retornar um erro em vez de sucesso. Portanto, se ocorrer qualquer instância de erro dentro do bloco `try`, automaticamente um objeto de erro será criado e transferido para dentro do bloco `catch`, podendo ser acessado por este parâmetro que chamei de `erro`. Normalmente, este parâmetro vem nomeado como `error` ou `e`, porém optei por `erro`, em português.

A partir desse momento, podemos capturar, dentro do parâmetro, qual foi o erro e este erro possui uma propriedade interna chamada `message`. Então, posso passar `erro.message` como uma _string_ na minha mensagem.

Esta é a nossa primeira tratativa de erro para que possamos criar um código que erra de uma forma esperada. Isto é, os erros não derrubam nossa aplicação - se for possível - e nem permanecem desconhecidos. Podemos descobrir com mais clareza onde os erros estão ocorrendo.

Agora, devemos adicionar a rota do `post` no nosso arquivo de rotas, que criamos no `livrosRoutes`. Mas antes de atualizar as rotas, faremos uma pequena refatoração. Vou usar aqui um padrão, que podemos chamar de _barril_ ou "_barrel_", que é um ponto de entrada para uma parte da aplicação.

No caso, como teremos bastante rotas, depois teremos rotas de autores, rotas de editoras e possivelmente muitas outras - cada uma podendo ter 5 ou mais rotas – faremos o seguinte: Dentro da pasta `routes`, criarei um arquivo que chamarei de `index.js`.

Esse `index` será, literalmente, o ponto de entrada das rotas, e é esse ponto de entrada que o resto da aplicação acessará.

Como isso funcionará?

No topo do arquivo `index.js`, vamos importar o express, pois é ele que gerencia nossas rotas.E também importarei `livros`:

```javascript
import express from "express";
import livros from "./livrosRoutes.js";
```

Em seguida, criaremos uma função para agrupar todas as rotas que receberemos. Chamada de `const routes` e criaremos uma _arrow function_ aqui. Dentro desse parâmetro, passarei `app`. Veremos o que esse `app` fará mais tarde.

Para não me esquecer, já vou exportar no final do arquivo, antes de prosseguir, com `export default routes`.

```javascript
import express from "express";
import livros from "./livrosRoutes.js";

const routes = (app) => {
};

export default routes;
```

Essa função que vamos criar será no Express. Lembra quando falamos sobre _middleware_, esses mini programas que colocamos para o Express executar em determinados pontos da aplicação e que conseguem capturar nossas requisições e respostas, e as manipular? Temos que centralizar nossas rotas.

Então, escreveremos a função `app.route()`. Aqui dentro, vou passar a rota como _string_. Para criarmos nossa URL base, vamos usar `app.route('/')`.

```javascript
import express from "express";
import livros from "./livrosRoutes.js";

const routes = (app) => {
  app.route("/").get((req, res) => res.status(200).send("Curso de Node.js"));

};

export default routes;
```

Agora, começaremos a incluir as rotas que estamos criando para `livros`. Futuramente, podemos criar rotas para `autores` e assim por diante.

Então, abaixo do nosso `app.route`, adicionaremos `app.use`. Lembrando que `use` é o método que nós usamos para incluir _middlewares_ em nossa instância do Express. Com a sintaxe `express.json()`, incluiremos mais um parâmetro aqui, que será `livros`.

```javascript
import express from "express";
import livros from "./livrosRoutes.js";

const routes = (app) => {
  app.route("/").get((req, res) => res.status(200).send("Curso de Node.js"));

  app.use(express.json(), livros);
};

export default routes;
```

E o que é `livros` nesse caso? São as nossas rotas que estão sendo exportadas e importadas de `livrosRoutes`. Assim, `app.use` está pegando nosso _middleware_ `.json` e todas as rotas de `livros` que estão sendo definidas dentro de `livrosRoutes`, passando para dentro de `routes`. A partir disso, o Express conseguirá gerenciar tudo de uma vez.

Agora, podemos voltar para `app.js`. No topo de `app.js`, não precisaremos mais importar `livro` do _model_, pois essa responsabilidade passou para o _controller_.

Sendo assim, podemos deletar essa linha. Em seu lugar, teremos que importar nossas rotas. Portanto, usamos `import routes from routes/index.js`. Ele já identificou e trouxe para nós com o JS no final desta vez.

Os primeiros _gets_ que criamos anteriormente, o `app.get` na barra, que retorna "curso de Node", pode ser deletado. Podemos também deletar `app.use express.json`, porque passamos a responsabilidade desse _middleware_ para nosso ponto de entrada das rotas. Por enquanto, vamos manter as outras rotas que criamos (`get-livros-e-por-id`, `get-post`), para assim podermos ir deletando-as com calma.

O que precisamos fazer agora é iniciar nossas rotas, que importamos. Aqui, `routes` é uma função, portanto, precisamos executar essa função. Abaixo, em nossa atribuição `const app="express"`, sob `app`, simplesmente chamaremos a função `routes` que importamos. O que passaremos para dentro dela? O `app`. Agora, o `app` que definimos como parâmetro em nossas rotas, lá no `index.js` das rotas, sabemos de onde ele está vindo e o que ele é: essa é nossa instância do _express_.

Assim, criamos a função `routes` em `routes-barra-index` e executamos `routes` em `app.js`, passando nosso servidor _express_ como parâmetro. Agora, tudo está fazendo mais sentido.

Finalmente, podemos testar no _Postman_ para ver se conseguimos pelo menos trazer um livro do _Atlas_.

Ao ir para o terminal, ele está indicando um erro em `import livros from livros-routes.js`. Desta vez, a mensagem é tranquila, dizendo que não existe um `export default`. Portanto, provavelmente, quando escrevi o código de `livros-routes.js`, me esqueci de exportar as rotas. Então, no final do arquivo, daremos um `export default` em `routes`. Agora, tudo deve funcionar.

Com a mensagem "conexão com o banco feita com sucesso", meu erro já passou. Podemos voltar ao _Postman_. Já tínhamos feito alguns testes com o _get_ em `barra-livros` que estava funcionando. Vou enviar novamente para ver se continua funcionando - está tudo ok, continua conectando com o banco e trazendo o nosso único livro.

Refatoramos bastante coisa. Se algo não estiver funcionando, dê uma olhada no repositório, compare o seu código para ver se não passou nada despercebido. Mas, por aqui, tudo certo. Podemos continuar, evoluindo a API e criando o restante das rotas. Vamos lá.