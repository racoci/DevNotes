# 2.06 Criando registros com POST

Por enquanto, a nossa API consegue buscar (_get_) dados. Quem especifica de onde vão vir os dados que vão ser retornados em uma requisição somos nós quando estamos programando a API. Estamos dizendo que os dados que a API vai retornar estão vindo de um _array_ que chamamos de `const livros`.

Lá no início do curso, comentamos que um sistema, por exemplo, de uma livraria, deve ser capaz não só de consultar livros, mas de adicionar livros também. É isso que vamos fazer agora.

Por enquanto, vamos continuar trabalhando no array local, que é o array da memória que estamos utilizando.

Então, vamos pensar como fazer para criar uma nova rota e conseguir não só buscar itens, mas adicionar itens, **criar registros** no nosso array, no nosso "banco de dados".

Vou criar uma nova rota para isso. Embaixo de `app.get`, vou criar `app.post`, o nome do método HTTP que utilizamos para criar recursos, criar novos recursos.

Qual rota o `post` vai acessar? Também vai acessar a mesma rota, `/livros`, já que estamos falando de adicionar livros. E o segundo parâmetro continua sendo os mesmos que estávamos trabalhando, que é `req` de requisição, `res` de resposta, criando uma função de seta (_arrow function_), abrindo e fechando chaves.

```javascript
app.post("/livros", (req, res) => {

})
```

Então, o que vai dentro do `post`?

Se estamos trabalhando com um array normal do JavaScript, vamos utilizar os métodos do JavaScript para manipulação de array. Então, o nosso `app.post` em `/livros` vai fazer um `livros.push`. E o que vai receber?

De onde vão sair os dados que vão ser utilizados para criar um novo livro? Eles vão sair de `req.body`, encerrado com ponto e vírgula.

```javascript
app.post("/livros", (req, res) => {
    livros.push(req.body);
})
```

Então, o que é `req.body`?

Já abordamos anteriormente o `req.url`. Sempre que falamos de `req` estamos falando do objeto requisição, que está sendo recebido dentro da função que é chamada em `app.post`. Todo o gerenciamento de ir na rota, pegar as informações e criar esses dois objetos, tanto o `req` quanto o `res`, é responsabilidade do Express.

Assim, o Express cria esse objeto `req` e dentro dele tem uma propriedade que chama `body`, ou seja, corpo. Que corpo é esse? É o corpo da requisição.

Vamos fazer novamente uma pausa para entender o `body`.

Falamos anteriormente sobre cabeçalhos (_headers_): Toda requisição e toda resposta HTTP tem cabeçalhos com as informações necessárias.

Porém, algumas requisições e respostas HTTP também têm `body`, também têm corpo. Quando só queremos buscar coisas com `get`, nossas requisições não precisam ter corpo, só precisam ter cabeçalho com as informações.

Porém, quando queremos enviar dados para serem criados, por exemplo, `post` cria um novo registro, nossa requisição também tem que ter um `body`, também tem que ter um corpo. No caso, a requisição HTTP tem que enviar os dados que queremos que sejam armazenados.

Normalmente, fazemos isso no formato de objeto e a resposta da requisição também tem `body`, que é o corpo, que normalmente é onde mandamos a informação de volta se isso deu certo ou se deu errado. Então, lembre-se sempre de que toda requisição HTTP tem cabeçalho e quando queremos enviar dados, por exemplo, em um `post`, temos que ter um corpo da requisição.

E esse valor fica guardado dentro do objeto requisição, dentro da propriedade `body`, criada pelo Express.

Então, voltando para o código, agora sabemos que o Express vai pegar o corpo dessa requisição e vai conseguir fazer um `push`, porque isso vai ser um objeto de livro, dentro do nosso array.

Antes de testarmos, tem um detalhe bem importante que temos que incluir lá no começo do nosso arquivo `app.js`, embaixo de onde criamos a `const app`. Trata-se do `app.use`, uma função, e vou passar como parâmetro uma outra função, que vai ser `express.json`.

```less
app.use(express.json());
```

Assim, temos aqui uma função executando outra função. Isso se chama **_middleware_**.

No caso do Express, esses _middlewares_ são utilizados para ter acesso às requisições e às respostas no momento em que elas estão sendo feitas, e para fazer algumas ações nelas, como por exemplo, modificar o objeto, passar informações extras etc.

Nós conseguimos encadear esses mini programas, esses _middlewares_, para fazer as alterações nas requisições e respostas conforme necessário. No meu caso, estou utilizando um chamado `express.json`, que serve para executar esse `express.json` em todas as requisições manipuladas pelo Express.

Ou seja, qualquer requisição cujo corpo é um objeto compatível com JSON, como um objeto com `id` e `título` ou um array de objetos, passará por esse _middleware_ e será convertido e analisado (ou 'parseado') para JSON.

Mas por que precisamos fazer essa conversão? Não estamos já trabalhando com objetos? Sim, estamos.

No entanto, toda vez que recebemos dados via corpo em uma requisição, eles chegam convertidos como _string_. Embora eles tenham o formato JSON, formato de objeto, com pares de chave-valor, eles viajam na conexão HTTP no formato _string_. Para conseguirmos utilizar os dados como JSON, ou seja, acessar as propriedades deles, precisamos converter essa _string_ novamente para JSON.

Importante lembrar que toda requisição deve ter uma resposta. Então, abaixo do local onde fizemos o _push_ do novo livro na nossa array `livros`, precisamos enviar uma resposta de volta para quem fez a requisição.

Portanto, teremos `res.status`. Agora, ao invés de 200, vou passar 201, que é o código de status HTTP para registro criado. Quando fazemos uma operação com sucesso em qualquer requisição, o código é 200. Quando criamos algo com sucesso, o código é 201.

E utilizarei também `.send`, porque vou passar uma _string_ dizendo "Livro cadastrado com sucesso". Neste caso, não precisamos de JSON, podemos usar apenas `.send`.

```javascript
app.post("/livros", (req, res) => {
    livros.push(req.body);
    res.status(201).send("Livro cadastrado com sucesso");
})
```

Agora, não conseguimos mais fazer o teste no navegador, porque o navegador só realiza requisições GET, ele não realiza outros métodos, ou seja, não posso passar um POST via navegador.

Portanto, agora precisaremos do **Postman**. As instruções de como baixar e instalar estão no começo dessa aula, no "Preparando o ambiente".

Precisaremos de um JSON para fazer uma requisição do tipo POST. Então, vamos lá. Eu já deixei o Postman aberto no meu computador. Vamos criar uma nova requisição com o Postman.

À esquerda, temos um menu com os métodos HTTP que podem ser utilizados. Já conhecemos o GET, que o próprio navegador realiza para nós, mas também podemos fazer pelo Postman. Selecionaremos o segundo, que é o POST.

A URL a ser utilizada é a nossa localhost:3000/livros.

E precisamos enviar um corpo nessa requisição. Então, abaixo do endereço, temos um menu, o "body". Clicarei nele, selecionarei a opção RAW e no último menu, que começa com texto, selecionarei JSON, que é o tipo de dado que queremos enviar na nossa requisição.

Abaixo, temos uma área para escrevermos nosso objeto. Criarei um novo objeto `livro` aqui, que tem `"id": 3` e o `"título": "O Silmarillion"`, outro livro de J. R. R. Tolkien.

Ao trabalharmos com JSON, sempre utilizamos aspas duplas nas chaves, assim como nos conjuntos de chave-valor, e também para as _strings_.

```json
"id": 3,
"titulo": "O Silmarillion"
```

Vou voltar ao terminal para ver se não há nenhum erro, o servidor está de pé.

Agora, no Postman, podemos clicar no botão que está à direita, "Send", e ver se ele retorna uma resposta. O servidor retornou "Livro cadastrado com sucesso".

Mas como saber se o livro foi mesmo cadastrado com sucesso? No Postman, há um botão com o símbolo de soma ('+') para abrir uma nova aba, onde podemos criar uma nova requisição e confirmar se o cadastro ocorreu como esperado.

Podemos ir para `/livros` em `localhost/livros` e fazer uma requisição do tipo _GET_ (que é a primeira opção de método). Lembrando que _GET_ não tem _body_, então apenas necessitamos enviar essa requisição clicando no botão _Send_.

Agora o Postman já retornou o meu _array_ atualizado, com _id 3_, título "O Silmarillion". Isso indica que, por enquanto, nossa API está funcionando.

Fizemos uma requisição do tipo _POST_ para `/livros`, ela adicionou o livro no _array_ de livros, utilizando os dados recebidos pela requisição e manipulados pelo _Express_.

Ou seja, _Express_ acessou a requisição, acessou a propriedade _body_, pegou o que havia dentro de _body_, que é o nosso objeto livro - _id 3_, título "Silmarillion" - e adicionou com o _push_ no _array_. Em seguida, retornou apenas com um _Send_ a mensagem "Livro cadastrado com sucesso".

Entretanto, fizemos uma nova requisição _GET_ e o _array_ veio atualizado. Qualquer alteração que fizermos e salvarmos o arquivo, assim que o _nodemon_ reiniciar o servidor, essas alterações vão desaparecer, porque esse _array_ está em memória.

Mas, por enquanto nós vamos ficar com essa configuração. Mais tarde, conseguiremos persistir nossos dados com um banco de dados.

Por enquanto, temos todo o processo funcionando, tanto para obter livros, quanto para criar um novo livro. Se pensarmos um pouco no que normalmente fazemos com dados, nós criamos, recuperamos, deletamos e atualizamos. É isso que nós vamos fazer em seguida, já utilizando o _Express_ e o nosso _array_ de livros. Então, vamos continuar.

Observe o resultado a seguir, onde o _array_ de livros é atualizado após a operação _POST_:

```python
GET /livros
[
  {
    "id": 1,
    "titulo": "O Senhor dos Anéis"
  },
  {
    "id": 2,
    "titulo": "O Hobbit"
  },
  {
    "id": 3,
    "titulo": "O Silmarillion"
  }
]
```

**Nota:** Lembre-se de que todas as alterações feitas serão perdidas assim que o servidor for reiniciado porque o _array_ de livros é apenas armazenado na memória.