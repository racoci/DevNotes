# 2.07 Buscando e atualizando livros

Agora que já sabemos como recuperar uma lista de livros da nossa base de dados em um _array_ e adicionar um novo livro, podemos continuar aprimorando nossa API com outras funcionalidades básicas.

O próximo passo é criar uma nova rota para acessar apenas um livro, que é algo muito comum para quando quero localizar um registro específico.

Nesse sentido, vou criar uma nova rota. Já sabemos que é uma rota do tipo `get`, pois queremos obter apenas um livro. Portanto, abaixo do último `app.get`, vou criar um novo `app.get`. Este será um _array_, mas a rota que vamos acessar não será mais `/livros`.

Terá que ser um pouco diferente, pois já temos um `get/livros`. Portanto, terá que ser `/livros`, seguido por um parâmetro que permitirá a localização de um livro específico.

No caso de nossa API, temos o título, mas temos uma informação mais precisa: o ID. O ID é um localizador único, que utilizamos para qualquer registro que precise de um localizador sem duplicação. Portanto, o que podemos passar em nossa rota é `get("/livros/")` com o ID que queremos localizar.

Como posso indicar ao Express que esse dado será variável? Eu prefixo isso com dois pontos. Portanto, teremos `/livros/:id`. Com esses dois pontos, estou informando ao Express que o ID será uma informação variável, que será processada de acordo com o valor que for passado.

O segundo parâmetro continua o mesmo, é a nossa conhecida _callback function_, que recebe `req` e `res` (requisição e resposta). Abro uma _arrow function_, seguida por chaves.

```javascript
app.get("/livros/:id", (req, res) => {

})
```

E o que acontecerá aqui dentro desse GET? Lembre-se de que ainda estamos trabalhando com um _array_ normal do JavaScript por enquanto, então continuamos usando os métodos do JavaScript. Portanto, o que o nosso GET livros fará? Ele precisa buscar, usando o JavaScript, um elemento nesse _array_ na propriedade ID.

Para facilitar o processo, vou separar em uma função distinta que possamos chamar dentro do nosso `app.get`. Depois do _array_, vou criar uma função normal do JavaScript com a declaração `function`, eu vou nomear essa função de `buscaLivro`.

A função `buscaLivro` vai receber um ID, que é o que vai chegar via requisição, naquela variável que mencionei com dois pontos. Essa função vai procurar dentro do _array_ `livros`, se existe um livro com esse ID e em qual índice ele está do _array_, para que possamos recupera-lo.

Portanto, ela vai retornar o resultado de `livros.findIndex`, que é um método do JavaScript para _arrays_ que retornam o índice onde está o elemento desejado, baseado no que passamos a ele.

Então, `findIndex` é um método _callback_ também, que vai receber cada livro do nosso _array_ de livros e vai retornar, por sua vez, se `livro.id` for estritamente igual ao ID recebido no parâmetro.

No entanto, lembre-se de que eu comentei que os dados que trafegam via HTTP, também trafegam no formato _string_. E nossos IDs no _array_ de livros, são _number_, ou seja, são números.

Para fazer essa comparação corretamente com os três iguais do JavaScript, primeiro precisamos converter esse ID para _number_. Então, `Number(id)`, caso contrário, ele vai tentar comparar uma _string_ com um número usando a comparação estrita e não vai dar certo.

```javascript
function buscaLivro(id) {
    return livros.findIndex(livro => {
        return livro.id === Number(id);
    })
}
```

Portanto, após a conversão, ele vai retornar o índice onde está esse livro dentro do _array_. Já que criamos a nossa função, podemos chamar essa função dentro da nossa requisição, dentro do `app.get`.

Voltando ao `app.get`, vamos criar uma `const index` para buscar esse índice e salvar na variável. Ele será o resultado de `buscaLivro`, que é a nossa função, recebendo o quê? `req.params.id`.

```csharp
app.get("/livros/:id", (req, res) => {
    const index = buscaLivro(req.params.id);
})
```

`Params` é outra propriedade que vem dentro do nosso objeto requisição, montado pelo Express. 'Params', por quê? Porque é um **parâmetro**. Estamos passando ID como um parâmetro da rota e usamos os dois pontos para indicá-lo como um parâmetro variável. O ID é o nome que nós atribuímos a esse parâmetro.

Então, se nós identificássemos com `livros/:id`, qualquer outro nome ou identificador, ele seria recebido como essa propriedade do objeto dentro de `params`. Para esclarecer `req.params` - porque pode haver mais de um - `req.params.id` vai puxar a requisição, passar para dentro de `buscaLivro` e, então, `buscaLivro` vai retornar algo e guardar esse número na constante `index`.

A partir disso, podemos acessar o nosso _array_ e passar isso adiante. Então, agora podemos criar a nossa resposta. `res.status` vai ser 200 (de OK), `res.status(200).json` e o resultado será o _array_ `livros[index]`, porque `index` é a posição que foi localizada pela função.

Vamos fazer um teste para esclarecer: Primeiro, vou verificar no terminal se o servidor está funcionando, sem nenhum erro. Com tudo em ordem, podemos voltar ao Postman e acessar a aba da requisição GET.

Agora, o nosso `id 3`, criado anteriormente, não existe mais porque o servidor já foi reiniciado. Porém, `id 1` e `id 2` permanecem, pois estão fixados no _array_.

Lembrando que a nossa rota é `/livros/`, e precisamos passar algum índice. Vou passar 1, que é o ID para o título "O senhor dos anéis", e, ao enviar, recebemos apenas o objeto com o `id 1`.

```json
{
"id": 1,
"titulo": "O Senhor dos Anéis"
}
```

Ou seja, a requisição recebeu esse ID como parâmetro, ele foi passado para dentro da função `buscaLivro`, a função `buscaLivro` localizou a posição no _array_ onde `livro.id` é igual a 1, retornou esse índice e, provavelmente, nesse momento, temos um livro no índice 0, que é o primeiro do _array_. Este é retornado para nós no formato JSON na resposta da requisição, tudo certinho.

Vamos aproveitar que estamos aqui e fazer, com mais agilidade agora, um método para alterar o nome de um livro, que é o método `put`. Utilizamos `get` para obter, `post` para criar e `put` ou `patch` para alterar um registro que já existe. Deixarei material extra sobre esses dois métodos para você conferir as diferenças entre eles.

Então, `app.put`, similarmente, vai ser na rota `/livros/`, mas aqui, novamente, temos que passar qual é o livro que queremos alterar. Também devemos passar o parâmetro para localizar qual é o livro que será alterado.

Segundo parâmetro permanece `req`, `res`, abre _arrow function_, abre chaves e, porque estamos trabalhando com o _array_ de JavaScript, começamos criando uma busca-livro. Podemos até copiar de `app.get`, nosso `const index = buscaLivro`, porque da mesma forma que tivemos que buscar um livro para retornar no GET, temos que buscar um livro para alterar.

Iniciamos buscando esse livro na nossa base, encontramos o livro na nossa base e, agora, simplesmente utilizamos um método JavaScript padrão para alterar o objeto. Então, `livros[index]`, por exemplo, não podemos alterar o ID, por padrão. O ID é um identificador único, mas podemos alterar o título. Então, podemos passar `livros[index].titulo` que será recebido e substituí-lo por `req.body.titulo`.

Lembrando que esta linha está apenas usando JavaScript padrão para encontrar uma propriedade qualquer de um objeto e substituir o valor dela.

Então, o valor atual está sendo substituído, no índice que está sendo passado, pelo valor de título que vamos receber no corpo da requisição, sem esquecer de enviar a resposta. Portanto, `res.status`, passaremos, aqui, `(200).json`. Vou simplificar esse exemplo, e pedir para retornar o _array_ inteiro novamente, para facilitar o retorno nesse teste. Tudo certo?

Vamos fazer mais um teste no _Postman_. No terminal, está tudo certo, sem nenhum erro. No _Postman_, podemos criar uma nova requisição. Vou copiar a URL que usamos no GET, clicar no ícone de soma ("+") para criar uma nova requisição do tipo `put`, que sempre precisa corresponder ao tipo que estamos passando no _Express_.

Irei fazer uma alteração, por exemplo, no livro, continuando a editar o ID1. O `put`, por necessitar o envio de dados, deve possuir um corpo. Portanto, no menu de corpo do _Postman_, seleciono _raw_, escolho o tipo _JSON_ e aqui passo apenas o título. Logo, crio aqui um objeto, passo título, entre aspas duplas, e aqui vou dizer que errei o título. O título estava errado, o Senhor dos Anéis, só o primeiro episódio. Então, "O Senhor dos Anéis, a Sociedade do Anel".

Pronto. Em seguida, vamos testar nossa requisição com send, `put`, _livros_, barra 1, e ele retornou o _array_ novamente, como havíamos solicitado que retornasse o _array_ inteiro como resposta, e ele alterou o título do ID1, "O Senhor dos Anéis, a Sociedade do Anel".

O que fizemos aqui foi praticar como utilizamos o _Express_ para vários métodos, os métodos do HTTP para várias operações que precisamos ser capazes de realizar em uma API. Buscar vários dados, buscar um dado, criar um dado novo, alterar um dado. Só falta conseguirmos excluir um dado, o que faremos em seguida.

E, além do corpo, passamos dados, enviamos dados de uma requisição via corpo da requisição, também conseguimos passar certos tipos de dados específicos de outras maneiras, por exemplo, via _param_, parâmetro da rota, que utilizamos aqui, assinalando com dois pontos.

Em seguida, o _Express_ pegou esse valor, alterou na rota, e assim conseguiu processar a requisição conforme precisávamos, com o número do ID, com o dado correto.

Portanto, só falta o `delete`, vamos finalizar aqui nosso primeiro teste com rotas do _Express_.