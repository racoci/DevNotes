Agora, sairemos um pouco do código para discutir sobre **decisões**.

Terminamos a aula anterior com um problema parcialmente resolvido, pois conseguimos identificar as mensagens problemáticas, enviar para a DLQ e obter os _logs_ que indicam porque elas estão indo para a DLQ.

Mas, o principal não é implementar a "fila", mas saber o que fazer para resolver o problema, isto é, entender como resolver o problema das mensagens que estão na fila.

Anteriormente, também combinamos de pensar em possíveis soluções. Apresentarei uma solução que normalmente é a primeira na qual pensamos. Então, temos um problema que é a mensagem que foi mandada para a DLQ. Podemos criar uma função que responderá, tendo como gatilho a entrada de uma mensagem DLQ.

Nessa função, podemos criar um algoritmo qualquer para analisar o objeto da mensagem e decidir de acordo com esse objeto:

- Se o formato estiver correto, segundo as possibilidades esperadas, podemos fazer o ciclo básico: o _redrive_ da DLQ, reenviando para a fila principal.
    
- Se o formato estiver incorreto, deletamos a mensagem.
    

![Slide intitulado "Problema: mensagem enviada para a DLQ". Abaixo, infográfico com formas ligadas por setas: 1. Função para analisar a mensagem; 2. Formato correto?; se sim, então 3. Reenvia para a fila; e 4. Fim!; se não, então 3. Deleta a mensagem.](https://cdn1.gnarususercontent.com.br/1/563691/8e7d561a-7b50-4875-b9d1-826a80ade7a4.png)

O caminho do ciclo básico é bastante simples. A AWS, inclusive, tem métodos com os quais podemos fazer esse _redrive_, ou seja, métodos com os quais podemos gerenciar a fila.

Como já mencionado, não estamos usamos esses métodos, porque tudo está sob a responsabilidade do Serverless. Mas, se você não estiver utilizando o Serveless, e, sim, o SQS, basta buscar pelos métodos na documentação da AWS.

O caminho quanto o formato está incorreto é um pouco mais complexo. Depois que deletamos a mensagem, o que acontece com o cadastro? Não podemos simplesmente descartar uma mensagem que deu errado, pois se trata de um cadastro.

A pessoa usuária fez um cadastro em lote e a funcionalidade com que estamos trabalhando precisa saber que um dos cadastros na lista do CSV não deu certo. O objeto não pode simplesmente desaparecer. Vamos pensar em algumas formas de resolver isso.

Poderíamos retornar esse erro para o _front_ e notificá-lo para a pessoa usuária, que pode simplesmente fechar a notificação. Geralmente, delegamos esse tipo de informação para uma fonte mais duradoura, por exemplo, um serviço como o e-mail.

Então, a pessoa recebe um e-mail com os dados do cadastro errado e pode corrigi-lo. Mesmo os sites que trabalham com feedback na tela, geralmente enviam coisas importantes, como o cadastro, por e-mail. Com o usuário notificado, podemos deletar a mensagem da DLQ.

Lembrando que a DLQ serve para análise (_debug_) e nós estamos trabalhando com uma fase após o _debug_. Algo "extra", que não vamos fazer, mas poderíamos, é salvar o resultado desses cadastros não concluídos em um banco à parte. Com isso, teríamos um registro mais duradouro das mensagens erradas.

Outra opção que não faremos seria passar a responsabilidade de validação para o serviço do CSV. Então, no serviço de conversão do CSV, poderia existir um validador de formato para validar nome e e-mail de acordo com as regras.

Feito isso, a mensagem seria enviada para o producer. Se não estivesse correta, o usuário seria notificado que uma das linhas do CSV, isto é, uma das linhas de cadastro está errada.

![Slide intitulado "Problema: mensagem enviada para a DLQ". Infográfico com formas ligadas por setas: 1.CSV; 2. Validador de formato {nome, email}; 3. Formato correto?; se sim, então 4. Envia mensagem para producer; se não, então 4. Notifica erro para usuário;](https://cdn1.gnarususercontent.com.br/1/563691/0af35c01-67d1-4a93-a965-c7cc1b1a1fd7.png)

Essa é uma refatoração possível e correta, mas que modificaria bastante o diagrama da nossa aplicação. Não é errado passar a responsabilidade para o CSV e já barrá-la. Neste caso, precisaríamos de uma DLQ de qualquer maneira, para manejarmos outros tipos de erros.

Neste caso, receberia o e-mail quem fez o cadastro no CSV, ou seja, a pessoa do B2B da plataforma receberia um aviso de que ela inseriu uma quantidade de pessoas usuárias e, dentre elas, alguma não deu certo.

A situação da nossa aplicação, é: temos três serviços, o extrator do CSV, a "presigned URL" e o serviço de chamada de API, que está comunicando a API REST. Tudo está funcionando, inclusive, os erros, porque já criamos uma DLQ para manejá-los no cadastro, considerando que uma validação que não foi feita passou.

As mensagens corretas estão sendo enviadas para o serviço correto, isto é, para a chamada de API, que está se comunicando com a API REST principal. Agora, podemos pensar em um serviço para cuidar do que está na DLQ, pois, por enquanto, não fizemos nada com as mensagens.

Então, podemos considerar outro serviço que faça o envio de e-mails. Lembrando que anteriormente, quando conversamos sobre produto, aprendemos que quem faz os cadastros via CSV é a pessoa interna do nosso B2B. Ela recebe os cadastros empresariais.

Sendo assim, é mais interessante que a pessoa cadastrada, ou seja, a aluna ou aluno, receba um e-mail dizendo que ela foi cadastrada na plataforma. O serviço pode ser utilizado tanto no caso de falha, quanto no caso de sucesso.

No caso de sucesso, quem recebe o e-mail é a própria pessoa estudante, nas falhas, quem recebe é a pessoa responsável pela administração da plataforma. A nossa "fila alunos para cadastrar" manda um e-mail de confirmação e a "dead letter queue" também envia um aluno para o serviço de e-mail de confirmação. Os dois casos utilizarão o mesmo serviço.

Uma ressalva, neste caso, é que se passarmos a responsabilidade de envio de e-mails para a fila de cadastros, ela acumulará muitas tarefas. De certa maneira, é um "desvio de função" da fila. Podemos utilizar outra fila para isso.

Então, vamos criar a nossa última fila: "fila de envio de e-mails" que vai interagir com o serviço de envio de e-mails:

- No caminho em que o formato está correto, o serviço de chamada de API manda um sinal de "cadastro de estudante com sucesso" para a fila de envio de e-mails.
    
- No caminho em que o formato está incorreto, a dead letter queue também envia uma mensagem para a fila de envio de e-mails, neste caso, avisando de que algo deu errado.
    

Tanto o sucesso, quanto a falha são encaminhados para a mesma fila de envio de e-mails, mas as informações são diferentes. Portanto, uma fila pode conter mensagens com conteúdos diferentes que serão interpretados de acordo com a condicional que adicionarmos ao serviço.

O cadastro correto está enviando um sinal para a fila de envio de e-mails, onde os e-mails de confirmação serão distribuídos. O mesmo vale para o caso das falhas. Essa fila é consumida pelo envio de e-mails, que processará tudo da melhor forma possível.

O envio de e-mail será responsável por lidar com as informações da fila, porque ela só envia e recebe, ela não cuida do processamento das informações.

Agora, vamos implementar esse envio de e-mails. Vamos lá!!