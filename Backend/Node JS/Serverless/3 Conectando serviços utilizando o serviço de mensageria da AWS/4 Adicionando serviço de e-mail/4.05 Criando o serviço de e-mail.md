Criamos uma nova fila e um novo _producer_ para organizar os envios de e-mails. Até aqui, nada diferente do que já fizemos. O próximo passo é **criar o serviço de e-mail em si**.

Uma questão, é: como usamos o serviço de e-mail? Durante o curso, utilizaremos uma biblioteca chamada [Nodemailer](https://nodemailer.com/about/), uma _lib_ sucinta, bastante usada em NodeJS.

Mesmo se utilizarmos uma biblioteca relativamente simples, ainda precisaremos de um servidor **SMTP** (Simple Mail Transfer Protocol). A criação dos servidores SMTP é um pouco trabalhosa. Existem muitas opções e, ainda que escolhêssemos o Gmail ou o próprio SES da AWS, necessitaríamos de muitas configurações de segurança e outros conhecimentos que não estão no escopo do curso.

Outro problema, é: acessando o "serverless > matriculas.csv", é possível notar que estamos usando alguns e-mails aleatórios. Como testar esses e-mails que, teoricamente, não chegarão a ninguém?

Felizmente, temos um serviço de e-mail fake, voltado para testes, que servirá para o nosso caso e para qualquer outro e-mail falso, o [Ethereal](https://ethereal.email/).

Basta acessar a página do **Ethereal**, apertar o botão de criação de conta, "Create Ethereal Account", e uma conta com dados fakes será criada. Atenção para não fechar janela que ele gerou, ou esses dados fakes serão perdidos.

Além dos dados, ele também traz a configuração básica do Nodemailer para criarmos um _transporter_. O **SMTP transport** é um software intermediário que faz toda a parte de conexão com o SMTP, autenticação de usuário, etc.

Podemos copiar a função que o Ethereal cria, retornar ao `index.js` e colá-la.

```php
module.exports.enviaEmailNoCadastro = async () => {
  const transporter = nomailer.createTransport({
    host: 'smtp.ethereal.email',
    port: 587,
    auth: {
      user: 'elizabeth9@ethereal.email',
      pass: 'xVqyycAu7y2s4bwaUZ'
    }
  });
```

> Antes de realizar as alterações necessárias nesse código, precisamos **instalar a biblioteca do Nodemailer**. Então, na página inicial, vamos copiar o comando `npm install nodemailer`, retornar ao Terminal, pasta _serveless_, e colaremos.
> 
> Com isso, a biblioteca será instalada. Ela é bem pequena, sem dependências externas, então, a instalação será bem rápida. Feito isso, podemos voltar ao arquivo `index.js`.

O primeiro passo no código gerado pelo Ethereal será importar a `nodemailer` sem as chaves. Então, no topo do arquivo, indicaremos que `const nodemailer` será igual a `required()`, com a _string_ `'nodemailer'` como parâmetro.

```php
const nodemailer = require('nodemailer');

module.exports.enviaEmailNoCadastro = async () => {
  const transporter = nomailer.createTransport({
    host: 'smtp.ethereal.email',
    port: 587,
    auth: {
      user: 'elizabeth9@ethereal.email',
      pass: 'xVqyycAu7y2s4bwaUZ'
    }
  });
```

Importamos a biblioteca! Agora, vamos criar outra função chamada `emailTransport = async ()`. Ela não precisa receber nenhum parâmetro. Nós abriremos uma arrow function e passaremos a `const transporter` dentro da função, deixando os elementos um pouco mais separados.

```php
const nodemailer = require('nodemailer');

const emailTransport = async () => { 
  const transporter = nodemailer.createTransport({
    host: 'smtp.ethereal.email',
    port: 587,
    auth: {
      user: 'elizabeth9@ethereal.email',
      pass: 'xVqyycAu7y2s4bwaUZ'
    }
  });
};

module.exports.enviaEmailNoCadastro = async () => {

};
```

Assim, temos uma função que cria o `transporter` e que será utilizada para enviar os e-mails de cadastro.

Se a função `enviaEmailNoCadastro` é o `handler` que está recebendo dados de um gatilho, receberá, por parâmetro, um evento, como toda função `handler` que criamos até agora.

```php
const nodemailer = require('nodemailer');

const emailTransport = async () => { 
  const transporter = nodemailer.createTransport({
    host: 'smtp.ethereal.email',
    port: 587,
    auth: {
      user: 'elizabeth9@ethereal.email',
      pass: 'xVqyycAu7y2s4bwaUZ'
    }
  });
};

module.exports.enviaEmailNoCadastro = async (evento) => {

};
```

Portanto, o gatilho manda dados para o evento e a função `enviaEmailNoCadastro` receberá esses dados através do objeto `evento`. Agora, podemos usar o restante dos métodos no Nodemailer. A documentação será disponibilizada na aula.

Basicamente, teremos que pegar o corpo da requisição que vem do `evento` e usá-lo para enviar a mensagem. Vamos começar pegando o corpo.

> Lembre-se de que há um objeto `Records` dentro do `evento`, no índice zero. O valor de `Records` é sempre um _array_, mesmo quando há apenas uma mensagem e uma posição.

```javascript
module.exports.enviaEmailNoCadastro = async (evento) => {
  const body = JSON.parse(evento.Records[0].body);

};
```

Com isso, pegamos o corpo da requisição. Provavelmente, será o objeto "aluno", que é o que está vindo dentro do cadastro. A partir daí, vamos montar o e-mail conforme os métodos do Nodemailer. Temos que chamar uma `const transport` e executar a função `emailTransport`. Então, passaremos um `await emailTransport()`, sem nenhum argumento.

```javascript
module.exports.enviaEmailNoCadastro = async (evento) => {
  const body = JSON.parse(evento.Records[0].body);
  const transport = await emailTransport();
  
    };
```

Criamos um novo _transporter_ de SMTP e agora usaremos a última função do Nodemailer: a `sendMail`. Vamos escrever `await transport.sendMail()`. Para funcionar, ela receberá, como parâmetro, um objeto. Dentro desse objeto, teremos as propriedades do e-mail que desejamos enviar:

1 - `from`: de quem é o e-mail?

2 - `to`: para quem vai o e-mail?

3 - `subject`: assunto do e-mail.

4 - `text`: texto do e-mail.

```javascript
module.exports.enviaEmailNoCadastro = async (evento) => {
  const body = JSON.parse(evento.Records[0].body);
  const transport = await emailTransport();
  await transport.sendMail({
    from:''
    to: 
    subject: '',
    text: ''
  });
};
```

Até aqui, estávamos usando o modelo da biblioteca. Agora, temos que pensar na razão deste serviço existir. Ele precisa existir para os dois casos:

- Caso de erro, que foi para a DLQ.
    
- Caso de sucesso, que vem da fila de cadastro.
    

Como devemos preencher o `from`, `to`, `subject` e `text`? Precisamos fazer uma condicional. O ideal, para a nossa organização, é criar outra _helper function_ para montarmos o objeto da mesma forma que fizemos com o _Fetch_.

Sendo assim, vamos acessar a pasta `utils` e criar outro arquivo, que chamaremos de `buildEmail.js`. Dentro dele, criaremos outra função `module.exports.buildEmail` e passaremos alguns parâmetros para ela. O nosso e-mail precisa das seguintes informações:

- Para quem será enviado? Como estamos usando o sistema fake do Ethereal, o remetente será sempre o mesmo.
    
- Qual é o assunto?
    
- Qual é o assunto? Isto é, qual é o corpo do e-mail.
    

Passaremos estes três dados como parâmetros: `to`; `subject`; e `text`. Não trabalharemos com o `from`.

```vbnet
module.exports.builEmail = (to, subject, text)
```

Em seguida, adicionaremos uma _arrow function_ com o retorno, que será um objeto com esses valores.

```javascript
module.exports.buildEmail = (to, subject, text) => {
  return {
      to, 
        subject,
        text
    }
};
```

> Lembrando que, no JavaScript, não é necessário escrever `to:to` quando as informações são iguais!

Com essa função, conseguimos passar no `sendMail`, caso a caso, as informações que desejamos usar para montar o e-mail. Em caso de sucesso, chamamos a função com determinadas informações e em caso de fracasso, chamamos a mesma função com outras informações.

Agora, retornaremos ao `index.js` e, no começo do e-mail, vamos importar a _helper function_ que criamos.

```php
const nodemailer = require('nodemailer');
const { builderEmail } = required('../../utils/buildEmail');

const emailTransport = async () => { 
  const transporter = nodemailer.createTransport({
    host: 'smtp.ethereal.email',
    port: 587,
    auth: {
      user: 'elizabeth9@ethereal.email',
      pass: 'xVqyycAu7y2s4bwaUZ'
    }
  });
};
```

Será que não poderíamos mudar um pouco nosso evento para que ele envie as informações de forma correta? Vamos pensar em como fazer isso a seguir!