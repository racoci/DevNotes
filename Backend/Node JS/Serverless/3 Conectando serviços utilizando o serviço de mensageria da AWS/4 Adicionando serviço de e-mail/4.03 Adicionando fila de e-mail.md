# 4.03 Adicionando fila de e-mail

Precisamos criar uma nova fila e um serviço de e-mail para ela. Vamos começar **criando a fila**!

Já sabemos como funciona, basta seguir o procedimento do _producer_ anterior. Então, no `serveless.yml`, na parte de `Resources`, temos a `FilaCadastro`. Podemos copiar os dados e colá-los abaixo, sempre lembrando de conferir se o alinhamento está correto.

```
    FilaCadastro:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: cadastro.fifo
        FifoQueue: true
        SqsManagedSseEnabled: false
        RedrivePolicy:
          deadLetterTargetArn:
            Fn::GetAtt:
              - DlqCadastro
              - Arn
          maxReceiveCount: 5
        VisibilityTimeout: 10
```

Então, colamos os dados da `FilaCadastro` e vamos chamar a nova fila de `FilaEmailConfirmacao`, ela será de tipo `AWS::SQS::Queue`. Nas propriedades, haverá um `QueueName`, onde definiremos o nome `emailconfirma.fifo`. Não trabalharemos com SSE.

Sobre a parte de `RedrivePolicy`, neste curso não trabalharemos com DLQ para essa fila. Nossa intenção é visualizar como funcionará o serviço de e-mail, por isso, podemos comentar toda a propriedade de `RedrivePolicy`.

Vamos deixar o `VisibilityTimeout` em 10, por enquanto.

```
    FilaCadastro:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: emailconfirma.fifo
        FifoQueue: true
        SqsManagedSseEnabled: false
        RedrivePolicy:
          deadLetterTargetArn:
            Fn::GetAtt:
              - DlqCadastro
              - Arn
          maxReceiveCount: 5
        VisibilityTimeout: 10
```

Depois, podemos até conferir os tempos de execução da função e mudá-los, se for o caso. Lembrando que é o _serveless_ quem está fazendo o gerenciamento de permissões dos serviços entre a fila e o lambda.

Então, na parte de `statements`, temos que adicionar mais um conjunto de `Effect`, `Action` e `Resource`. Para isso, vamos copiar o que se referia à fila de cadastro e colar. Este outro conjunto, também permitirá todas as ações em `sqs`, mas o recurso será `FilaEmailConfirmacao`.

```
- Effect: Allow
          Action: 
            - s3:GetObject
          Resource: 
            - arn:aws:s3:::alunos-csv/*
        - Effect: Allow
          Action: 
            - sqs:*
          Resource: 
            Fn::GetAtt: [FilaCadastro, Arn]
        - Effect: Allow
          Action: 
            - sqs:*
          Resource: 
            Fn::GetAtt: [FilaEmailConfirmacao, Arn]
```

Abaixo, na parte de `environment`, vamos repetir a linha na qual criamos uma variável de ambiente para a fila, assim, ela pode ser utilizada pela aplicação, ou seja, para que a referência da URL dela possa ser identificada pelo JavaScript.

A outra variável de ambiente se chamará `SQS_QUEUE_EMAILCONFIRMA_URL` e fará referência ao recurso `FilaEmailConfirmacao`.

```
 environment:
    STAGE: ${sls:stage}
    ACCESS_KEY_ID: ${param:ACCESS_KEY_ID}
    SECRET_ACCESS_KEY: ${param:SECRET_ACCESS_KEY}
    SQS_QUEUE_CADASTRO_URL: { Ref: FilaCadastro }
    SQS_QUEUE_EMAILCONFIRMA_URL: { Ref: FilaEmailConfirmacao }
```

Por enquanto, a fila foi criada no _serveless_. Ainda não fizemos o _deploy_, mas ela já está prevista. O próximo passo é criar um _producer_. Para isso, retornaremos à pasta `cadastroProducer.js`. Vamos fazer um "copia e cola" para conferirmos o que é possível aproveitar do código desta pasta.

Então, vamos copiar o arquivo `cadastroProducer.js`, colar na pasta `producers` e trocar o nome do arquivo para `emailConfirmaProducer`. As três primeiras linhas, onde:

1 - Puxamos o _client_ do arquivo onde estamos iniciando um `clientSQS`.

2 - Pegamos o método `SendMessageCommand` diretamente da biblioteca `@aws-sdk`.

3 - Usamos o `crypto` para criar uma ID de 36 caracteres.

```
const { client } = require('../../../config/clientSQS');
const { SendMessageCommand } = require('@aws-sdk/client-sqs');
const crypto = require('crypto');
```

Também podemos deixar a linha seguinte, apenas alterando o nome da função para `email.ConfirmaProducer`.

```
module.exports.emailConfirmaProducer = async (objAluno) => {
```

O `email.ConfirmaProducer` precisa receber um objeto "aluno". Por enquanto, podemos deixá-lo como sendo o parâmetro e, depois, decidimos se trabalharemos com ele para montar o e-mail.

Lembrando que "aluno" é um objeto simples que tem duas propriedades: nome e e-mail. Na função, temos a constante `input`, usada para gerar mensagens.

A propriedade `SQS_QUEUE_CADASTRO_URL`, nós já sabemos que agora se chamará `SQS_QUEUE_EMAILCONFIRMA_URL`. Nossa variável de ambiente pegará essa URL do _serveless_. O restante, podemos deixar como está, exceto o `MessageGroupId`, onde criaremos um novo grupo chamado `'email'`.

Lembrando que, no SQS, as filas `.fifo` usam o ID de grupo para ordenar as mensagens. Em uma fila `.fifo`, o primeiro registro que entra é, também, o primeiro que sai. Através do `MessageGroupId`, as mensagens são ordenadas e processadas.

```
const { client } = require('../../../config/clientSQS');
const { SendMessageCommand } = require('@aws-sdk/client-sqs');
const crypto = require('crypto');

module.exports.emailConfirmaProducer = async (objAluno) => {

  const input = {
    QueueUrl: process.env.SQS_QUEUE_EMAILCONFIRMA_URL,
    MessageBody: JSON.stringify(objAluno),
    DelaySeconds: 0,
    MessageDeduplicationId: crypto.randomUUID(),
    MessageGroupId: 'email',
  };
```

A parte do "try/catch", onde usamos os métodos do SQS para mandar mensagem ficam iguais. No `console.log` de `'mensagem enviada com sucesso'`, podemos até especificar `'mensagem email enviada com sucesso'`. Mas, basicamente, não haverá mais nenhuma modificação nesta parte.

```
try {
    const command = new SendMessageCommand(input);
    const mensagem = await client.send(command);
    console.log('mensagem email enviada com sucesso', mensagem.MessageId);
    return mensagem;

  } catch (erro) {
    console.error(erro);
  }
};
```

O código completo fica assim:

```
const { client } = require('../../../config/clientSQS');
const { SendMessageCommand } = require('@aws-sdk/client-sqs');
const crypto = require('crypto');

module.exports.emailConfirmaProducer = async (objAluno) => {

  const input = {
    QueueUrl: process.env.SQS_QUEUE_EMAILCONFIRMA_URL,
    MessageBody: JSON.stringify(objAluno),
    DelaySeconds: 0,
    MessageDeduplicationId: crypto.randomUUID(),
    MessageGroupId: 'email',
  };

  try {
    const command = new SendMessageCommand(input);
    const mensagem = await client.send(command);
    console.log('mensagem email enviada com sucesso', mensagem.MessageId);
    return mensagem;

  } catch (erro) {
    console.error(erro);
  }
};
```

Por último, podemos retornar ao `serveless.yml` e criar a função com a qual ligaremos a fila. A parte de `functions` será parecida com a `cadastroConsumer`, reagindo a um evento SQS. Então, podemos copiar os dados da função `cadastroConsumer` e colá-los abaixo. Sempre prestando atenção no alinhamento.

Chamaremos a fila nova de `enviaEmailNoCadastro`. Sobre o `handler`, a ideia é criar uma nova pasta de um novo serviço em `src/functions` e ela se chamará `enviaEmailNoCadastro`. Dentro dela, criaremos um arquivo `index.js` e, nele, a função `enviaEmailNoCadastro`.

```
enviaEmailNoCadastro:
    handler: src/functions/enviaEmailNoCadastro/index.enviaEmailNoCadastro
    events:
      - sqs:
          arn:
            Fn::GetAtt:
              - FilaCadastro
              - Arn
          batchSize: 1
    timeout: 2
```

Os eventos aos quais a função vai reagir também serão de tipo `sqs`, pegará o `arn`, mas o recurso que reagirá não é mais o `FilaCadastro`, mas, sim, o `FilaEmailConfirmacao`. O `batchSize` continua sendo 1 e o `timeout`, 2. Conforme conversamos, posteriormente, é possível modificar esse valor.

```
enviaEmailNoCadastro:
    handler: src/functions/enviaEmailNoCadastro/index.enviaEmailNoCadastro
    events:
      - sqs:
          arn:
            Fn::GetAtt:
              - FilaEmailConfirmacao
              - Arn
          batchSize: 1
    timeout: 2
```

Basicamente, neste vídeo relembramos como se cria uma fila, uma função e um evento. Agora, podemos criar a função e ir para a parte principal: usar um serviço de e-mail. Vamos lá!!