Anteriormente, conversamos que seria bem mais interessante **criar um objeto**, isto é, uma mensagem que faça mais sentido para a fila que estamos usando, ao invés de ficar passando o objeto "aluno" de um lado para outro.

Se estamos usando uma fila de e-mail, é importante que a mensagem chegue tenha a ver com o e-mail. Para isso, no nosso serviço de envio de e-mails, vamos fazer duas coisas:

1 - Na função `emailTransport`, copiamos uma `const Transporter` que executa o `.createTransport`.

```php
const nodemailer = require('nodemailer');

const emailTransport = async () => { 
  const transporter = nodemailer.createTransport({
    host: 'smtp.ethereal.email',
    port: 587,
    auth: {
      user: 'elizabeth9@ethereal.email',
      pass: 'xVqyycAu7y2s4bwaUZ'
    }
  });
};
```

Na verdade, não precisamos dessa variável. Basta retornar o resultado do método `createTransport()`.

```php
const nodemailer = require('nodemailer');

const emailTransport = async () => { 
  return nodemailer.createTransport({
    host: 'smtp.ethereal.email',
    port: 587,
    auth: {
      user: 'elizabeth9@ethereal.email',
      pass: 'xVqyycAu7y2s4bwaUZ'
    }
  });
};
```

2 - Na função principal, `enviaEmailNoCadastro`, vamos manter o `evento`, porque ele será modificado para receber um objeto de e-mail, assim como fizemos na função _helper_.

Sobre o nosso `sendMail()`, como agora os dados virão do e-mail, podemos preencher o `from` com o e-mail fake anterior, porque é o único e-mail que temos para usar. Então, vamos deixá-lo _hardcode_, como _string_.

```javascript
module.exports.enviaEmailNoCadastro = async (evento) => {
  const body = JSON.parse(evento.Records[0].body);
  const transport = await emailTransport();
  await transport.sendMail({
    from:'elizabeth9@ethereal.email',
    to: 
    subject: '',
    text: ''
  });
};
```

As demais propriedades, `to`, `subject` e `text`, agora receberemos do `evento`. Então, o `to` será igual a `body.to`; o `subject` será igual a `body.subject`; e o `text` será igual a `body.text`.

```javascript
module.exports.enviaEmailNoCadastro = async (evento) => {
  const body = JSON.parse(evento.Records[0].body);
  const transport = await emailTransport();
  await transport.sendMail({
    from:'elizabeth9@ethereal.email',
    to: body.to,
    subject: body.subject,
    text: body.text,
  });
};
```

Feito isso, quando criarmos a mensagem que será enviada para a fila de e-mail, a mensagem terá o formato acima. Muito melhor que receber uma mensagem genérica e tentar lidar com ela dentro do método que serve para enviar e-mails, não gerar mensagens de e-mail.

A função `enviaEmailNoCadastro` é acionada em um gatilho, o `FilaEmailConfirmacao`, mas está faltando chamar o _producer_. Inclusive, criamos um `emailConfirmaProducer.js`, mas ele não está sendo chamado ainda para enviar mensagens para a fila. Então, quem está gerando a mensagem que desejamos levar para a fila de e-mail?

O serviço responsável por enviar a mensagem para a fila de envio de e-mails é o serviço de cadastrar alunos. Vamos retornar ao código e refatorar a função `cadastrarAlunos`, que está em `cadastrarAlunos.js`, para gerar a mensagem que desejamos.

A parte do `try`, vai fazer a `chamadaApi` e retornará uma resposta dessa chamada. Por enquanto, está tudo certo. Não precisamos fazer mais um `buildResponse`, porque essa função não vai mais retornar nada, apenas enviará uma mensagem. Então, podemos apagar a linha da `const res`.

A `chamadaApi` continua guardando os dados da resposta da requisição. No topo do arquivo, vamos importar a nossa `const { buildEmail }`. A função `buildResponse` não está mais sendo dada, portanto, não precisamos mais importá-la.

```javascript
const config = require('../../../config/config.json');
const { fetchApi } = require('../../../utils/fetchHelpers');
const { FetchErro } = require('./erros/FetchErro');
const { buildEmail } = require('../../../utils/buildEmail');
```

Também temos que importar o `emailConfirmaProducer` , porque ele será chamado para enviar a mensagem.

```javascript
const config = require('../../../config/config.json');
const { fetchApi } = require('../../../utils/fetchHelpers');
const { FetchErro } = require('./erros/FetchErro');
const { buildEmail } = require('../../../utils/buildEmail');
const { emailConfirmaProducer } = require('../producers/emailConfirmaProducer');
```

Dentro do `try`, podemos trocar o nome da nossa `const chamadaAPI` para `res`, de resposta da requisição. Algo muito importante, que não podemos deixar de fazer, é criar uma `const objAluno`, que será o resultado de `JSON.parse()` recebendo `aluno`.

```javascript
const config = require('../../../config/config.json');
const { fetchApi } = require('../../../utils/fetchHelpers');
const { FetchErro } = require('./erros/FetchErro');
const { buildEmail } = require('../../../utils/buildEmail');
const { emailConfirmaProducer } = require('../producers/emailConfirmaProducer');

module.exports.cadastrarAlunos = async (aluno) => {

  try {
    const res = await fetchApi(`${config.fetchApi.prod}/alunos`, 'POST', 'application/json', aluno);

    const objAluno = JSON.parse(aluno);

    if (res.statusCode === 201) {

  //código omitido. 
```

Estamos trafegando objetos e _strings_, porque lidamos com requisições HTTP. O `evento` também manda tudo como _string_. Precisamos do aluno como objeto, porque temos que acessar algumas propriedades dele, como nome e e-mail. Se estiver como _string_, não conseguiremos fazer isso.

Pode acontecer de algumas vezes "parsearmos" para JSON, transformarmos em _string_ outra vez, tudo isso pode ser uma fonte de erro. Por isso, é sempre estar atento ao formato que estamos recebendo.

Infelizmente, no JavaScript a nossa verificação de tipo ficou um pouco prejudicada. Mas, não podemos deixar de fazer o `JSON.parse`, porque o `aluno` vai chegar em `cadastrarAlunos` como _string_ e queremos como objeto.

Então, criamos a `const objAluno` e, agora, basta enviar tudo para o _producer_. Isso será feito dentro do `if`, porque queremos que a mensagem vá para a fila apenas se o `statusCode` for 201.

Na primeira linha do `if`, vamos passar `await` e chamar o _producer_ `emailConfirmaProducer()`. O parâmetro é a própria mensagem que desejamos enviar. Neste caso, temos que gerar o objeto de e-mail que nos propomos a a criar para enviar a mensagem corretamente.

Como parâmetro de `emailConfirmaProducer()`, vamos chamar a função `buildEmail()`. Os parâmetros de `buildEmail()` serão:

- `objAluno.email`, que se refere ao endereço de e-mail de quem envia e de quem recebe.
    
- `Cadastro de ${objAluno.nome} na plataforma`, que se refere à linha de assunto do e-mail.
    
- `O cadastro do email ${objAluno.email} foi feito com sucesso.`, que se refere ao texto do e-mail e pode ser de qualquer tamanho. Nós estamos passando uma frase com texto plano, porque se trata de um teste.
    

```javascript
if (res.statusCode === 201) {

      await emailConfirmaProducer(buildEmail(
        objAluno.email,
        `Cadastro de ${objAluno.nome} na plataforma`,
        `O cadastro do email ${objAluno.email} foi feito com sucesso.`));
      return {
        mensagem: 'sucesso no cadastro',
        status: res.statusCode
      };
    }
```

Nosso objeto de e-mail está sendo construído e passado para o e-mail _producer_. Com isso, estamos trabalhando com uma mensagem bem mais adequada para o que desejamos fazer.

Agora, a função que envia e-mails vai receber o que precisa e poderemos passar os dados corretos para cada caso. O que passamos no `201` foi a mensagem do caso de sucesso, onde o e-mail será enviado diretamente para a pessoa que foi cadastrada, não para a funcionária(o) do B2B que efetuou o cadastro.

Embora estejamos usando um exemplo fake, ele pode ser substituído por qualquer serviço de e-mail, se tivermos um servidor SMTP rodando. O processo será basicamente o mesmo, porque o Nodemailer trabalha com os mesmos métodos.

Já lidamos com o caso de sucesso, agora, cuidaremos do e-mail que falhou. Vamos lá!!