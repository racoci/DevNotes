# 4.08 Tratando o caso de erro

O caminho que liga nosso serviço de chamada API à fila de envio de e-mails e ao serviço de envio de e-mails está pronto. Agora, falta fazer o caminho que liga a DLQ à fila de serviço de e-mails. Este é o caso do e-mail que falhou.

Perceba que esse caminho é um pouco diferente, porque ao invés de termos uma fila com um _producer_ e um _consumer_ que ligam dois serviços, vamos fazer duas filas diretamente interligadas, sem um serviço.

> Lembrando que, no primeiro caso, nosso _producer_ ligava a fila de alunos para cadastrar ao extrator CSV e a fila de alunos para cadastrar à chamada de API.

Então, precisamos de um _producer_ da fila de DLQ que liga um _consumer_ à fila de envio de e-mails. É isso que faremos agora. Retornando ao código, vamos acessar a pasta de `consumers`. Nela, criaremos um novo arquivo chamado `trataErrosCadastroConsumer.js`.

Da mesma forma que fizemos anteriormente com os _producers_, podemos acessar o `cadastroConsumer.js`, apertar "Ctrl + A" e "Ctrl + C" para copiar o código pronto, colar em `trataErrosCadastroConsumer.js` e analisar o que podemos aproveitar.

```javascript
const { cadastrarAlunos } = require('../cadastroAlunos/cadastrarAlunos');

module.exports.cadastroConsumer = async (evento) => {
  console.log('DADOS EVENTO DO CONSUMER', evento);

  try {
    const { body } = evento.Records[0];
    return cadastrarAlunos(body);
  } catch (erro) {
    console.error('falha no envio para cadastro');
    throw erro;
  }
};
```

A importação de `cadastrarAlunos` nós não usaremos, porém, precisamos trazer nosso _helper_ de envio de e-mails. Lembrando que faremos com que a função de envio de e-mails receba o objeto e-mail pronto. Sendo assim, na primeira linha, importaremos a nossa _helper function_ `buildEmail`.

```javascript
const { buildEmail } = require('../../../utils/buildEmail');

module.exports.cadastroConsumer = async (evento) => {
  console.log('DADOS EVENTO DO CONSUMER', evento);

  try {
    const { body } = evento.Records[0];
    return cadastrarAlunos(body);
  } catch (erro) {
    console.error('falha no envio para cadastro');
    throw erro;
  }
};
```

Agora, precisamos fazer duas filas se comunicarem sem que elas sejam o meio, e que as pontas sejam dois serviços. A função que se chamava `cadastroConsumer` agora se chamará `trataErrosCadastroConsumer`. Ela continuará recebendo um `evento` e consumirá, através do _serveless_, um objeto do SQS.

```javascript
const { buildEmail } = require('../../../utils/buildEmail');

module.exports.trataErrosCadastroConsumer = async (evento) => {
  console.log('DADOS EVENTO DO CONSUMER', evento);

  try {
    const { body } = evento.Records[0];
    return cadastrarAlunos(body);
  } catch (erro) {
    console.error('falha no envio para cadastro');
    throw erro;
  }
};
```

Também podemos retirar o `console.log` e a parte de "try/catch", porque já aprendemos como funciona o tratamento de erros e não implementaremos uma utilidade real para esse "try/catch". Com isso, nossa função ficará um pouco mais curta. Além disso, podemos usar "Ctrl + '.' (ponto)" para resolver os problemas de identação.

```ruby
const { buildEmail } = require('../../../utils/buildEmail');

module.exports.trataErrosCadastroConsumer = async (evento) => {

  const { body } = evento.Records[0];
  return cadastrarAlunos(body)

};

//{"nome":"Paulo","email":"pauloemail"}
```

Nós ainda precisamos da primeira linha da função, que é a `const { body }` recebendo `evento.Records[0]`, pois temos que pegar, justamente, o _body_ do `evento`, independentemente do que estiver dentro dele.

Precisamos adicionar mais uma `const`, que chamaremos de `const aluno` e será o resultado de `JSON.parse()` em `body`, para obtermos o objeto "aluno", que é o objeto de e-mail.

```javascript
const { buildEmail } = require('../../../utils/buildEmail');

module.exports.trataErrosCadastroConsumer = async (evento) => {
  const { body } = evento.Records[0];
  const aluno = JSON.parse(body);

};

//{"nome":"Paulo","email":"pauloemail"}
```

Se nossa intenção é comunicar duas filas, precisamos comunicar o _consumer_ de uma, que vem da DLQ, e o _producer_ da outra, que é a fila de e-mail de confirmação. Então, o último comando que passaremos ao JavScript será `await` e chamaremos o `emailConfirmaProducer` que criamos anteriormente.

Sendo assim, no início do arquivo, vamos importar essa função `emailConfirmaProducer`.

```javascript
const { buildEmail } = require('../../../utils/buildEmail');
const { emailConfirmaProducer } = require('../producers/emailConfirmaProducer');

module.exports.trataErrosCadastroConsumer = async (evento) => {
  const { body } = evento.Records[0];
  const aluno = JSON.parse(body);

  await 
};

//{"nome":"Paulo","email":"pauloemail"}
```

Após o `await`, vamos chamar essa função. O parâmetro de `emailConfirmaProducer()` será o objeto que enviaremos na mensagem. Este objeto é um modelo de e-mail pronto para ser enviado, `buildEmail()`. Em `buildEmail()`, temos que passar "to", "subject" e "text".

Lembrando que este é o caso de erro! No caso de sucesso, passamos o dado de e-mail do aluno, porque queremos que ele próprio receba o e-mail avisando que ele foi cadastrado.

Aqui, como se trata de um caso de erro, nós criaremos uma _string_ e deixaremos, em _hardcode_, um e-mail fictício. Por exemplo: `admin@plataforma.com`. Neste caso, quem fez o cadastro dos alunos é que receberá a informação de que um dos cadastros não deu certo e, então, poderá resolver o problema.

Estamos passando `admin@plataforma.com`, mas no caso de haver uma autenticação no _front-end_, poderíamos pegar os dados dessa sessão, por exemplo, identificar quem criou o cadastro para a pessoa receber, etc.

```javascript
const { buildEmail } = require('../../../utils/buildEmail');
const { emailConfirmaProducer } = require('../producers/emailConfirmaProducer');

module.exports.trataErrosCadastroConsumer = async (evento) => {
  const { body } = evento.Records[0];
  const aluno = JSON.parse(body);

  await emailConfirmaProducer(buildEmail(
    'admin@plataforma.com', )
};

//{"nome":"Paulo","email":"pauloemail"}
```

O segundo parâmetro do `buildEmail()` é o _subject_, ou seja, o texto/assunto do e-mail. Também criaremos um _template string_ com acento agudo, mas o assunto será `Cadastro de ${aluno.nome} não efetuado`. Com isso, a pessoa receberá um e-mail e poderá resolvê-lo.

```javascript
const { buildEmail } = require('../../../utils/buildEmail');
const { emailConfirmaProducer } = require('../producers/emailConfirmaProducer');

module.exports.trataErrosCadastroConsumer = async (evento) => {
  const { body } = evento.Records[0];
  const aluno = JSON.parse(body);

  await emailConfirmaProducer(buildEmail(
    'admin@plataforma.com', 
    `Cadastro de ${aluno.nome} não efetuado`, ));
};

//{"nome":"Paulo","email":"pauloemail"}
```

O terceiro parâmetro do `buildEmail()` também será um _template string_: `O cadastro do email ${aluno.email} não foi concluído.`.

```javascript
const { buildEmail } = require('../../../utils/buildEmail');
const { emailConfirmaProducer } = require('../producers/emailConfirmaProducer');

module.exports.trataErrosCadastroConsumer = async (evento) => {
  const { body } = evento.Records[0];
  const aluno = JSON.parse(body);

  await emailConfirmaProducer(buildEmail(
    'admin@plataforma.com', 
    `Cadastro de ${aluno.nome} não efetuado`, 
    `O cadastro do email ${aluno.email} não foi concluído.`));
};

//{"nome":"Paulo","email":"pauloemail"}
```

Por fim, deixaremos esse gatilho no `serveless.yml`. Será a última função que vamos criar. Também copiaremos os dados da última função criada até então, porque também será um evento de SQS.

```yaml
enviaEmailNoCadastro:
    handler: src/functions/enviaEmailNoCadastro/index.enviaEmailNoCadastro
    events:
      - sqs:
          arn:
            Fn::GetAtt:
              - FilaEmailConfirmacao
              - Arn
          batchSize: 1
    timeout: 2
```

O nome da nova função será `emailErroCadastro`. O `handler` será `src/functions/consumers/trataErrosCadastroConsumer` e o nome da função será o mesmo `trataErrosCadastroConsumer`.

O evento é `sqs`. Também trabalharemos com `arn`, mas, ao invés de reagirmos à `FilaEmailConfirmacao`, o _serveless_ reagirá ao evento na nossa `DlqCadatro`. Então, a partir do momento em que aparece uma mensagem `DlqCadastro`, ela é direcionada para a "fila envio de e-mails".

O `batchSize` continua sendo 1 e o `timeout` continua sendo 2.

```yaml
  emailErroCadastro:
    handler: src/functions/consumers/trataErrosCadastroConsumer.trataErrosCadastroConsumer
    events:
      - sqs:
          arn:
            Fn::GetAtt:
              - DlqCadastro
              - Arn
          batchSize: 1
    timeout: 2
```

Com isso, já estamos em condições de fazer nosso último _deploy_ e realizar um teste. Voltando ao Terminal, vamos rodar o comando `sls deploy`. Em seguida, faremos nosso último teste de ponta a ponta, ou seja, do _front-end_ à inserção na API base.

O deploy foi concluído com sucesso no Terminal e podemos realizar o novo teste. Adicionamos outros nomes no arquivo `matriculas.csv` para nos localizarmos melhor no navegador onde visualizamos o retorno da API principal.

|nome|email|
|---|---|
|Fernando Coelho|fernando@email.com|
|Ana Moraes|ana@email.com|
|Lais Oliveira|lais@email.com|

Vamos testar na própria tela do _front_. Apertaremos o botão "Browser" e carregaremos o arquivo `matriculas.csv`. Depois, apertaremos "Criar registros em lote". No _front-end_, apareceu o _feedback_ que já existia: upload de arquivo concluído.

Agora, vamos à aba do _endpoint_ da API, conferir se os nomes que acabamos de colocar entraram. Recarregando a página, é possível visualizar que os nomes entraram com sucesso. São três nomes novos: Ana Moraes, Fernando Coelho e Lais Oliveira.

Feito isso, vamos ao servidor de e-mail fictício, o Ethereal. Há um botão logo após os dados da conta, o "Open Mailbox". Apertando este botão, acessaremos a caixa de entrada.

Nele, encontraremos o e-mail informando o cadastro de Lais Oliveira na plataforma, assim como o de Ana Moraes e Fernando Coelho. Eles estão sendo enviados diretamente para o e-mail dos alunos.

Para o último teste, vamos retornar ao arquivo `matriculas.csv`, apagar todos os registros para que eles não entrem duas vezes. Deixaremos apenas um e-mail, escrito propositalmente errado.

|nome|email|
|---|---|
|Ricardo Ford|ricardocom|

Retornaremos ao _front-end_ e recarregaremos a página. O arquivo CSV está salvo e nós o carregaremos novamente. Após apertaremos "Criar registros em lote", o _upload_ do arquivo foi concluído.

Depois, recarregaremos a API original. Nenhum registro entrou. Agora, vamos acessar a caixa de entrada do Ethereal par recarregar as mensagens. Ainda não entrou nada, mas, temos que lembrar que existe um _timeout_ e cinco tentativas de entrega que acontecem de 10 em 10 segundos no _serveless_.

Podemos ir ao Console do _serveless_, recarregar a página, acessar "invocations" de "functions" nos últimos 15 minutos e esperar um pouco, pois, o Console do _serveless_ às vezes fica um pouco dessincronizado. Se tudo der certo, os erros devem aparecer.

Em seguida, um e-mail deve chegar no Ethereal com os dados solicitados, ou seja, um e-mail com os dados solicitados é enviado para o "admin" da plataforma.

Recarregando a página do _serveless_, tudo que estávamos prevendo apareceu. Existem 5 chamadas de "cadastroConsumer" no Console, ou seja, cinco tentativas de entrega. Acessando o _log_ de qualquer uma delas, o `FetchErro` está "estourando", e é isso que queremos.

Na caixa de mensagens do Ethereal, ao recarregarmos a página, encontraremos o e-mail para o "admin@plataforma.com" avisando que o cadastro de Ricardo Ford não foi efetuado.

Agora, temos uma versão dos serviços mais completa que no começo do curso, bem desacoplada e que não está esquecendo de enviar os _feedbacks_ para o usuário através de um serviço de envio de e-mail. Lembrando que o usuário é a parte que interessa em toda essa aplicação.

Se você pensou que seria possível fazer uma função de envio de e-mail que recebesse dois gatilhos vindos de filas diferentes — da DLQ e da fila convencional de alunos para cadastrar, e realizando a separação entre e-mail de erro e e-mail de sucesso dentro do serviço — você está certo!

No nosso projeto, trabalhamos com uma função reagindo a um evento só, mas, é possível fazer com que uma fila reaja a mais de um evento, por exemplo, a um evento de duas filas. Porém, passaríamos ao serviço de e-mail a responsabilidade de separar o sucesso e o fracasso, portanto, o código não ficaria tão organizado.

No nosso código está tudo bem separado: o serviço de envio de e-mail apenas faz o envio do e-mail, pois recebe uma mensagem indicando tudo que deve ser feito.

Nosso próximo passo é recapitular tudo que fizemos até agora e discutir um pouco das escolhas de arquitetura que fizemos no projeto. Vamos lá!!