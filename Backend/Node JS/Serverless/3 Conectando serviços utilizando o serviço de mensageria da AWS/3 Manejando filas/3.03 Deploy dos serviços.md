# 3.03 Deploy dos serviços

Vamos testar. Acessando o terminal, dentro da pasta "serverless", faremos um novo _deploy_.

```
sls deploy --stage=prod
```

Após aguardar os minutos necessários para subir a aplicação, o _deploy_ será concluído no terminal. Vamos aproveitar este momento para realizar um teste completo.

Já subimos o front com o comando `npm start` no terminal, portanto, vamos acessar a página da aplicação pelo navegador no `localhost:3000` e abrir a aba do console à sua direita.

Vamos realizar um cadastro para verificar se o ciclo da aplicação funciona perfeitamente. Lembrando que nosso serviço de cadastro presente da API já é capaz de realizar o `fetch()` na API REST base.

Vamos descer a página da aplicação até a seção "Selecione um arquivo para fazer o cadastro em lote" e clicar no botão "_Browse_" (explorar). Na janela de upload de arquivos, acessaremos a pasta "serverless" e realizar um clique duplo no arquivo `matriculas.csv`. Em seguida, clicaremos no botão "Criar registros em lote".

A tela retornará a mensagem "upload do arquivo concluído". Isso confirma somente o upload do arquivo.

Vamos acessar a aba da API no navegador e atualizar a página para verificar que os três novos registros foram adicionados com sucesso.

> 0:
> 
> _id: "647f8c2876a599097d89dca1"
> 
> nome: "Ana Souza"
> 
> email: "ana@email.com"
> 
> 1:
> 
> _id: "647f8c2856909e2bd65c6a41"
> 
> nome: "Carlos Marques"
> 
> email: "carlos@email.com"
> 
> 2:
> 
> id: "647f8c280d21673e0da9a6f8"
> 
> nome: "Lana Corcel"
> 
> email: "lana@email.com"

Estes dados correspondem ao que temos no arquivo `matriculas.csv`.

> **Observação:** Os nomes foram modificados para facilitar a visualização da entrada.

Com isso, constatamos que o ciclo da aplicação funciona até agora. Saímos de uma situação simples e adicionamos ao Serverless os serviços de extrair o CVS, de gerar a URL e da chamada da API (os três funcionam).

O extrator envia mensagens para a fila, que as recebe. O Consumer é ativado pelo gatilho no Serverless, envia o conteúdo da mensagem (um objeto aluno) para a chamada de API. Este último fica isolado, realizando somente a conexão do Serverless com a API REST base. Esta, por sua vez, não sabe do que ocorre no resto da aplicação — isso é o correto, pois cada serviço faz a sua parte sem interferir no trabalho de outros.

Para conferir todas as etapas realizadas e as funções chamadas, é possível conferir o console do Severless, na guia "_explorer_". Ali, são listadas todas as chamadas de API realizadas. Acessando a guia "_invocations_", localizada abaixo de "_explorer_", veremos uma lista provando que todas as nossas funções _lambda_ foram chamadas.

|**timestamp**|function|duration|memory|cold start|errors|
|---|---|---|---|---|---|
|06/06 16:42:32.735|cadastroConsumer|30 ms|104 mb (10%)|0 ms|none|
|06/06 16:42:32.654|cadastroConsumer|47 ms|102 mb (10%)|0 ms|none|
|06/06 16:42:32.387|cadastroConsumer|200 ms|92 mb (9%)|245 ms|none|
|06/06 16:42:31.575|extraiDadosCsv|256 ms|127 mb (12%)|1 s|none|
|06/06 16:42:25.000|enviarUrlPreassinada|85 ms|111 mb (11%)|…|…|

Se clicarmos em cada chamada, abriremos a seção "log", onde poderemos conferir os _logs_ que trazem o conteúdo do `console.log()`, como, por exemplo, o que possui `INFO` e também a _stack_ quando algum erro ocorrer.

Acessando a guia da Amazon SQS no navegador, na seção "_Queues_" (filas), podemos clicar em "cadastro.fifo" e consultar a seção de monitoramento das filas, na guia "_Monitoring_" (monitorando). Nela, veremos as entradas e saídas das mensagens, que serão deletadas automaticamente pelo SQS.

Por fim, acessando a guia da Amazon aberta na seção "_Lambda_" acessada pelo caminho "Lambda > Fuctions", temos uma lista de funções.

|**Function name**|
|---|
|serverless-3-prod-cadastroConsumer|
|serverless-3-prod-extraiDadosCsv|
|serverless-3-prod-enviarUrtPreassinada|

Podemos clicar em cada função para acessá-las. Após o clique, veremos a seção "_Function overview_" (Visão geral da função). Abaixo dela, temos uma barra de guias, na qual selecionaremos "_Monitor_" (monitoramento). Nesta seção, teremos uma barra secundária de guias, na qual selecionaremos "Logs" para visualizar os _logs_ do _CloudWatch_.

Esses _logs_ chegam em lotes (_batches_).

|#|**Timestamp**|**RequestID**|**LogStream**|**DurationInMS**|**BilledDurationInMS**|**MemorySetInMB**|**MemoryUsedInMB**|
|---|---|---|---|---|---|---|---|
|1|2023-06-06T19:42:32.764Z|381487d3-a8cd-Sbc9-9b17-db2a2693f3d3|2023/06/06/[$LATEST] 5ed5fb30a48f449a9cda4668bd0cbda3|30.32|31.0|1024|104|
|2|2023-06-06T19:42:32.700Z|0148343b-1055-5c34-bab0-68c29e0b70c8|2023/06/06/[$LATEST] 5ed5fb30a48f449a9cda4668bd0cbda3|47.2|48.0|1024|102|
|3|2023-06-06T19:42:32.5842|c4b32adf-3d81-5e53-9da8-7626b3dcca8f|2023/06/06/[$LATEST] Sed5fb30a48f449a9cda4668bd0cbda3|200.03|201.0|1024|92|
|4|2023-06-06T19:12:37.7612|850ce472-291e-Sa15-a0ab-b88bae475f2c|2023/06/06/[$LATEST]64a7c52f9c8d4da89284d005fb2b8cfe|25.44|26.0|1024|114|
|5|2023-06-06T19:12:37.6982|d7553463-8e55-5b14-a197-684a090d564d|2023/06/06/[$LATEST]64a7c52f9c8d4da89284d005fb2b8cfe|39.25|40.0|1024|…|
|6|2023-06-06T19:12:37.6192|7f58ad10-1f0d-Sdce-a343-f1e998557930|2023/06/06/[$LATEST]64a7c52f9c8d4da89284d005fb2b8cfe|101.9|102.0|1024|…|
|7|2023-06-06T19:10:45.2012|d7661cbd-f9a6-55d9-9405-40447f47e0e0|2023/06/06/[$LATEST]64a7c52f9c8d4da89284d005fb2b8cfe|41.58|42.0|1024|…|
|8|2023-06-06T19:10:45.099Z|a66d5ab6-821f-5624-9f17-064f04ffae21|2023/06/06/[$LATEST]64a7c52f9c8d4da89284d005fb2b8cfe|208.27|209.0|1024|…|
|9|2023-06-06T18:16:56.1142|Se88f89d-a05f-58fc-909a-a464da1aa4a6|2023/06/06/[$LATEST]1216a51d03c44fb8a555964094d34a95|6.26|7.0|1024|…|

Clicando em um dos lotes na coluna **LogStream**, uma nova guia será aberta no navegador, onde veremos a seção "CloudWatch" da Amazon.

Nós acessamos três locais diferentes para acessar informações, e isso é um tipo de _trade off_ (troca). O Serverless realiza muitas funções automaticamente e abstrai o trabalho que teríamos com a AWS SDK, lidando com eventos e mensagens. Se acessarmos o arquivo `serverless.yml` por meio do explorador do VSC, veremos em seu interior que há uma seção para a configuração e permissão das filas.

Trabalhando com Serverless, delegamos a implementação a ele e recebemos em troca a necessidade de um monitoramento mais complexo, que depende de acessar vários consoles.

> **Dica:** Existem aplicações de monitoramento, mas não trataremos deles neste curso. Contudo, disponibilizaremos conteúdos sobre elas na seção de atividades.

A fila básica e o caminho feliz estão completos. A seguir, veremos o que fazer quando as coisas dão errado.

O que acontece se:

- Uma mensagem se perder?
- O Consumer não consumir uma fila?
- Uma mensagem chegar incorreta?
- O serviço de cadastro não receber a mensagem?

Vamos aprender a lidar com esses tipos de situação.