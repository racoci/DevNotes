# 3.12 Analisando logs de erros

Anteriormente, rodamos o _deploy_, que foi concluído com sucesso. Vamos testar a aplicação.

A API principal está preparada para não receber requisições que não possuem a formatação correta. Se houverem dados incorretos, o cadastro não será feito e um erro será retornado.

Tiraremos proveito disso para fazer os testes darem errado e forçar mensagens a entrarem na DLQ. Acessando a página do console da Amazon SQS, por meio do navegador, e nela acessaremos o menu hambúrguer (constituído de três linhas horizontais) no canto superior esquerdo, selecionando "Queue" na aba lateral que será aberta.

Isso abrirá a seção "_Queues_" (filas) no corpo da página. Em seu interior, veremos uma tabela com as nossas filas: "cadastro-dql.fifo" e "cadastro.fifo". Vamos clicar na segunda que corresponde à nossa fila original.

Com isso, abriremos a seção "cadastro.fifo". Na porção superior da página, à direita deste título, selecionaremos o botão "_Send and receive messages_" que, conforme a tradução diz, nos dá a opção de enviar e receber mensagens diretamente.

Com o clique, a página exibirá a seção "_Send and receive messages_" (enviar e receber mensagens) que possui um formulário com campos de input. O primeiro, no topo, é rotulado "_Message body_" (corpo da mensagem).

No final do arquivo `cadastroConsumer.js`, disponibilizamos o código abaixo em formato de comentário. Ele possui o e-mail em formato incorreto.

```
//{"nome": "Paulo", "email": "pauloemail"}
```

Vamos copiar este conteúdo mal-formatado sem as barras de comentário e colar no campo "_Message body_". Esperamos que, estando neste formato, ele não seja cadastrado na API principal e que ela nos retorne um erro.

Abaixo de "_Message body_", temos outros dois campos com duas propriedades que precisam ser preenchidas na fila FIFO: "_Message group ID_" (ID do grupo de mensagem) e "_Message deduplication ID_" (ID de deduplicação de mensagem).

Preencheremos o primeiro campo com o nome dado ao grupo de mensagens:

```
cadastro
```

O segundo será preenchido com o nome dado ao grupo de mensagens:

```
12345
```

A comparação é feita pelos ID de deduplicação, portanto, devemos preenchê-lo com um valor único para permitir ao SQS comparar e descobrir se uma mensagem está duplicada ou se são duas mensagens diferentes com o mesmo corpo.

Após o preenchimento dos três campos, clicaremos no botão "_Send message_" (enviar mensagem), localizado no canto superior direito do formulário. Com isso, receberemos um _feedback_ na tela, informando que a mensagem foi enviada.

Voltaremos à guia do console do Serverless, clicaremos na guia "_explorer_" e na guia secundária "_invocations_". Como visto anteriormente, veremos uma tabela com todas as invocações de função.

Um dos pontos negativos do console do Serverless é a demora para sincronizar e a aparição eventual de erros. Devido a isso, precisaremos aguardar e recarregar a página algumas vezes até a nossa chamada aparecer.

Após um tempo, veremos 5 invocações de `cadastroConsumer`, conforme esperávamos.

|**Timestamp**|function|duration|memory|cold start|errors|
|---|---|---|---|---|---|
|06/07 15:34:36.080|cadastroConsumer|20 ms|105 mb (10%)|0 ms|Error|
|06/07 15:34:35.069|cadastroConsumer|28 ms|105 mb (10%)|0 ms|Error|
|06/07 15:34:32.907|cadastroConsumer|33 ms|105 mb (10%)|0 ms|Error|
|06/07 15:34:31.854|cadastroConsumer|29 ms|100 mb (10%)|0 ms|Error|
|06/07 15:34:31.515|cadastroConsumer|203 ms|95 mb (09%)|299 ms|Error|

Lembrando que configuramos 5 tentativas de recebimento. A primeira delas realizou um _cold start_ que levou 299 milissegundos, a partir do qual o SQS tentou entregar a mensagem mais 4 vezes.

Se clicarmos em qualquer chamada de função, veremos suas informações na seção "_transaction details_" (detalhes da transação). Descendo essa página, veremos as seções "_stacktrace_" e "_log_" com as informações que queremos ver, escritas em vermelho.

> **stacktrace**
> 
> ```
> 
> src/functions/cadastroAlunos/cadastrarAlunos.js 19 throw new FetchErro(res.statusCode, aluno); ↑ Error código HTTP não esperado
> ```

> **log**
> 
> ```
> 
> 03:34:36 pm 2023-06-07T18:34:36.094Z bd8fe3b6-441c-5f8d-93c3-bf4c8be790ab ERROR PetchErro [Error]: código HTTP não esperado at module.exports.cadastrarAlunos (/var/task/src/functions/cadastroAlunos/cadastrarAlunos.js:19:11) at process.processTicksAndRejections (node: internal/process/task_queues: 95:5) { statusCode: 400, aluno: { "nome": "Paulo", "email": "pauloemail" } }
> ```

Em "_stacktrace_", vemos nossa mensagem sobre o código HTTP que não foi esperado e no "_log_" temos _log_s de erro com o `FetchErro`, a mensagem do HTTP não esperado, a _stack_ que a classe `Error` sempre envia e o objeto `aluno: { "nome": "Paulo", "email": "pauloemail" }` por extenso. Neste, podemos verificar quais dados podem estar incorretos (neste caso, o e-mail) e descobrir se o CSV deixou passar algum caso que não deveria.

Isso significa que os erros foram ativados com sucesso. A intenção da DLQ não é simplesmente armazenar mensagens, e sim disponibilizá-las para as pessoas responsáveis analizarem e descobrirem os motivos do erro.

Além do console do Serverless, podemos acessar o console do SQS da AWS, clicar na guia "_Monitoring_", abaixo da seção da nossa fila "cadastro.fifo", e carregar alguns gráficos. Entre eles, buscaremos três:

- "_Number of Messages Received_" (número de mensagens recebidas)
- "_Number of Messages Sent_" (número de mensagens enviadas)
- "_Number of Messages Deleted_" (número de mensagens deletadas)

Nestes gráficos, podemos ver que uma mensagem foi enviada, uma foi recebida e nenhuma mensagem deletada. Este comportamento padrão é muito importante e ocorre quando as mensagens são enviadas com sucesso.

Nesta seção de gráficos, vimos que uma parte da fila se comporta como esperado. Vamos acessar o menu _breadcrumb_ acima do título "cadastro.info" e clicar na etapa anterior à atual ("_Queues_").

Nessa tela, clicaremos na fila "cadastro-dlq.info" e acessaremos a mesma seção, clicando em "_Monitoring_" na parte inferior.

Após o carregamento, veremos no gráfico "_Aproximate Number of Messsages Visible_" (número aproximado de mensagens visíveis), veremos que há uma mensagem visível nos últimos minutos.

Com isso, vimos que mensagens apareceram no DLQ e não foram deletadas da fila principal.

Observamos na prática o processo de não entregar uma mensagem pela fila principal e enviá-la ao DLQ. Um dos principais usos da DLQ é exatamente esse: produzir _logs_ das exceções, analisar o conteúdo das mensagens na fila, diagnosticar os problemas e resolvê-los para que não hajam mais mensagens sendo enviadas para ela.

A partir disso, passaremos a pensar em como realizar capturas de erros e onde estes devem ser exibidos.

Conseguimos ver o que está acontecendo, mas a mensagem continua na DLQ — ou seja, temos um cadastro que ainda não foi efetuado.

Para o próximo vídeo, vamos pensar em qual seria a melhor solução para trabalhar com as mensagens da DLQ.

Neste caso, existem algumas opções e caminhos que podem ser seguidos. A seguir, entenderemos qual decisão tomar.