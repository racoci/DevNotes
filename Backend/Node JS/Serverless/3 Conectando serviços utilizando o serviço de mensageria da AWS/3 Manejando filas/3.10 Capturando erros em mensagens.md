# 3.10 Capturando erros em mensagens

Vamos focar nas DLQs (_dead-letter queues_) e entender para que existem.

Na [documentação da AWS](https://docs.aws.amazon.com/pt_br/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html), temos um diagrama com o ciclo básico de funcionamento da DLQ em conjunto com sua fila principal.

![Diagrama com ciclo de funcionamento da DLQ. Na ponta esquerda, temos "producer applications" (aplicações que enviam mensagens). Uma seta sai dessa aplicação e aponta para "source queue" (fila de origem) que aponta para para "consumer applications" (aplicações que consome mensagens) na ponta direita. No centro do diagrama, o letreiro "Amazon SQS" engloba "source queue" e "dead-letter queue" (fila de mensagens mortas) e suas políticas. A "source queue" aponta para "dead-letter queue" passando por "redrive policy" (política de redirecionamento). Enquanto "dead-letter queue" aponta para "source queue" passando por "DLQ Redrive to source queue" (redirecionamento DLQ para fila de origem).](https://cdn1.gnarususercontent.com.br/1/1319058/957facbf-7ea8-475e-abbb-b12c60fa02b5.png)

Em uma ponta, temos o _**producer**_, ou seja, a aplicação que está produzindo as mensagens. Ela envia uma mensagem para o _**source queue**_ que é a fila base/principal. Na outra ponta, temos a aplicação _**consumer**_ que é quem está consumindo as mensagens.

Assim, o ciclo básico sai da _producer_, sai da _source queue_ e entra na _consumer_ através dessa fila.

Nesse ciclo básico de vida, a **DLQ** (_dead-letter queue_) tem uma função que é o _**redrive policy**_. Inclusive, colocamos essa propriedade no `serverless.yml`. O _redrive policy_ são as políticas de _retry_ (retentativas).

O uso mais básico é a DLQ reenviar para a fila principal. Por isso, nesse diagrama, podemos usar o _redrive policy_ para redirecionar as mensagens que não foram consumidas para a DLQ e a DLQ reenvia de volta para a fila principal.

Esse redirecionamento é uma questão de produto. Pode ser que em alguns produtos que você trabalhe, o _redrive_ faça sentido. No nosso produto, não vamos utilizar essa abordagem.

> A principal tarefa da DQL não é simplesmente ser uma "fila de _back-up_" das mensagens que não foram consumidas. A DQL existe para que as mensagens que deram erro e não foram entregues possam ser "isoladas" e debugadas.

Quem vai fazer esse _debug_ somos nós que trabalhamos no produto. Não adianta mandar as mensagens para a DLQ e não entender porque estão indo para lá e não fazer nada com os erros.

Também precisamos decidir o que fazer com as mensagens que estão na DLQ. Vamos apagar? Ou vamos devolvê-las para a fila? O que precisamos fazer vai variar de acordo com produto.

Nesse caso, vamos conferir o que vai fazer sentido para o nosso contexto.

Por isso, vamos lembrar quais são as funções que estão envolvidas com a nossa fila: a `cadastroConsumer.js` pega as mensagens da fila e `cadastrarAlunos.js` que é o serviço que ligado no _consumer_ que utiliza as mensagens.

Como focamos em outra funcionalidades, não colocamos nenhuma ferramenta específica para lidar com os erros nesses dois arquivos. Agora, vamos precisar fazer essa tarefa de verificar o que foi para a DLQ e poder debugar o porquê foi para essa fila de mensagens mortas.

Sem colocar algumas ferramentas de erro nessa parte da aplicação, os erros ocorrem silenciosamente e não vamos conseguir visualizar onde aparecem.

Erros não são pokémons. Não precisamos pegar todos em todas as partes do código. Queremos pegar erros específicos e que aconteçam de formas específicas em partes específicas da aplicação.

É nesses dois arquivos que vamos querer que esses erros "estourem". Primeiro, vamos focar na `cadastrarAlunos.js` que tem apenas um `try-catch` por enquanto. Dentro do `try`, colocamos um `if` para fazer uma verificação simples se o `statusCode` é igual ao esperado, o `201` de registro criado.

A API principal nos retorna o _status code_ de `201`, o qual é passado através do `fetch` que está sendo feito na API.

Depois, apenas colocamos um `return` genérico de mensagem "outro status". Mas, nem faz muito sentido. Afinal, se o _status code_ não for `201`, vai ser uma mensagem de erro que queremos pegar.

Para ficar mais organizado, dentro da pasta "src > functions > cadastroAlunos", vamos criar outra pasta chamada "erros". Dentro dela, vamos criar um arquivo chamado `FetchErro.js`.

Em `FetchErro`, vamos criar um erro mais específico ao invés de usar erros genéricos nativos que não nos ajudam.

Para isso, criamos uma classe `FetchErro` que vai estender da classe de `Error` nativa do JavaScript.

Entre as chaves, vamos criar um `constructor()` da classe. Por parâmetro, queremos que esse construtor receba o `statusCode` porque senão deu `201`, queremos saber qual _status_ foi retornado.

Também vamos passar como segundo parâmetro do construtor, o `aluno`. Afinal, para entender e conseguir debugar o erro, é essencial verificar no log o que é enviado, ou seja, o objeto `aluno` que é o corpo da requisição.

No corpo do construtor, vamos passar `super()`. Dentro, vamos passar uma _string_ que vem da superclasse `Error`. O texto será `código HTTP não esperado`. Você pode colocar a mensagem de erro que quiser.

Além disso, vamos passar o `this.statusCode` igual à `statusCode` que vem do construtor. Também passamos `this.aluno` igual à `aluno` que vem do construtor.

Assim, criamos uma classe de erro estendendo da classe de `Error` básica do JavaScript. Vamos exportar essa classe através do `module.exports` igual à `FetchErro` entre chaves.

> `FetchErro.js`:

```js
class FetchErro extends Error {
  constructor (statusCode, aluno) {
    super('código HTTP não esperado');
    this.statusCode = statusCode;
    this.aluno = aluno;
  }
}

module.exports = { FetchErro };
```

Inclusive, você pode criar outros erros específicos a partir do que criamos e exportá-los.

Após criar a classe, podemos ir em `cadastrarAlunos.js` e fazer esse erro acontecer. Primeiramente, precisamos importar a classe `FetchErro` no topo do arquivo.

Para isso, digitamos `const { FetchErro }` igual à `require()` e o local do arquivo entre aspas simples. Isto é, `./erros/FetchErro`.

Onde vamos criar essa nova instância de `FetchErro`?

No bloco `try`, queremos que a aplicação entre dentro do `if` e já dê o retorno de sucesso. Porém, se não entrar no `if`, vamos retirar o retorno genérico com mensagem de "outros status". No lugar, vamos fazer o erro acontecer.

Vamos digitar `throw` para lançar um `new FetchErro()`, ou seja, uma nova instância. O primeiro parâmetro vai ser trazido da superclasse.

Agora, passamos o `res.statusCode` que vem da resposta da requisição que é a `const res` da linha 10. Em seguida, passamos `aluno` que vem como argumento da função `cadastrarAlunos`. Por isso, basta colocá-lo dentro do erro.

No `catch`, podemos manter o `console.error()`. Contudo, esse `console` sozinho só joga uma informação no console. Isso não faz com que o erro seja lançado.

Por isso, vamos dar `throw` em `erro` que chega no `catch()` via parâmetro. Assim, já deve ser lançado o `FetchErro` para fora.

> `cadastrarAlunos.js`:

```js
const { FetchErro } = require('./erros/FetchErro');

module.exports.cadastrarAlunos = async (aluno) => {

  try {
    const chamadaApi = await fetchApi(`${config.fetchApi.prod}/alunos`, 'POST', 'application/json', aluno);

    const res = buildResponse(chamadaApi.statusCode, chamadaApi.body, chamadaApi.headers);

    if (res.statusCode === 201) {
      return {
        mensagem: 'sucesso no cadastro',
        status: res.statusCode
      };
    }

    throw new FetchErro(res.statusCode, aluno);

  } catch (erro) {
    console.error(erro);
    throw erro;
  }
};
```

Após lançar o erro, queremos que ele estoure em `cadastroConsumer.js`. É onde o erro precisa ser capturado e logado para que possamos verificar o que aconteceu.

Em `cadastroConsumer.js`, o `try` não é modificado. Assim, retorna o resultado de `cadastrarAlunos` que é a requisição.

No `catch(erro)`, podemos deixar o primeiro `console.error()` que contém um texto. Mas, vamos pagar o `console.error(erro)` e dar um `throw` em `erro`.

> `cadastroConsumer.js`:

```js
const { cadastrarAlunos } = require('../cadastroAlunos/cadastrarAlunos');

module.exports.cadastroConsumer = async (evento) => {
  console.log('DADOS EVENTO DO CONSUMER', evento);

  try {
    const { body } = evento.Records[0];
    return cadastrarAlunos(body);
  } catch (erro) {
    console.error('falha no envio para cadastro');
    throw erro;
  }
};
```

O `FetchErro` é gerado em `cadastrarAlunos` e é propagado para o `catch` de `cadastrarAlunos` para depois bater no _consumer_ e ser capturado pelo `catch` de `cadastroConsumer` e ser jogado para fora.

Esse `throw` de `cadastrarConsumer` é o que queremos pegar nos logs para verificar o que aconteceu.

Agora, podemos fazer o deploy e testar. No terminal, dentro da pasta "serverless", vamos rodar novamente o comando:

```console
sls deploy --stage=prod
```

Como leva um tempo para executar, vamos parar esse vídeo por aqui. Vamos voltar quando o deploy estiver finalizado.