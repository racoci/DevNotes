Criamos o Producer e o Consumer, intermediários em nosso diagrama. Por enquanto o Consumer não chama nada, portanto devemos implementar o serviço do _Serverless_ que processará cada objeto `aluno` e criar a ponte para a _API REST_. Com isso, o ciclo de cadastro se completará.

Voltaremos ao VSC e acessaremos o explorador lateral.

Dentro do caminho "serverless > src > functions" temos a pasta `extratorCsv`, trazida do curso anterior, que já possuía em seu interior a função `cadastrarAlunosNoBd`. Esta, por sua vez, se encontra dentro do arquivo `cadastrarAlunosNoBd.js`.

Vamos aproveitar parte do código dessa função, pois vamos utilizá-la em outro contexto. Para isso, vamos criar uma pasta denominada "cadastroAlunos" para o nosso serviço, dentro da pasta "src / functions". Clicaremos no módulo `cadastrarAlunosNoBd`pelo explorador e o arrastaremos para dentro da pasta recém-criada. Por fim, na janela de confirmação, pressionaremos o botão "Move".

Renomearemos o arquivo movido de `cadastrarAlunosNoBd.js` para `cadastrarAlunos.js` e também a função em seu interior, de `module.exports.cadastrarAlunosNoBd` para `module.exports.cadastrarAlunos`.

Vamos manter as importações do `config` e do `fetchApi`, pois o primeiro é a fonte do endereço da API REST e o segundo se trata das _helper functions_ (funções auxiliares) criadas para nos ajudar a realizar `fetch()`s (requisições) de forma organizada.

```javascript
const config = require('../../../config/config.json');
const { fetchApi } = require('../../../utils/fetchHelpers');

module.exports.cadastrarAlunos = async (alunos) => {
  const alunosPromessas = alunos.map(async (aluno) => {
    return fetchApi(`${config.fetchApi.prod}/alunos`, 'POST', 'application/json', JSON.stringify(aluno));
  });
  const respostas = await Promise.all(alunosPromessas);

  if (respostas.some((resposta) => resposta.statusCode !== 201)) {
    throw new Error('Houve um erro no cadastro de um ou mais alunos');
  }
};
```

O que a função `cadastrarAlunos` passará a receber entre parênteses? Anteriormente, ela recebia um arranjo de `alunos`. Agora, ela receberá um único `aluno`. Vamos modificar o interior dos parênteses de `alunos` para `aluno`.

Considerando que trabalharemos com `aluno` e não com o arranjo, podemos remover o `map()` que realizava a interação dele. Portanto, removeremos a linha `const alunosPromessas = alunos.map(async (aluno) => {`, e a linha `});` que fecha essa função.

Após a remoção, o VSC apontará erros, pois temos o `return` no início da função. Com isso, todo o código após ele fica inacessível.

Para evitar esse problema, deletaremos a palavra-chave `return` alinhado à esquerda, na primeira linha da função.

Cada `aluno` terá o próprio `fetch()` na API principal e uma resposta. Portanto, na primeira linha da função, temos uma requisição HTTP normal.

Desse modo, no lugar do `return` removido, criaremos uma `const chamadaApi` que receberá um `await` e a função `fetchApi()` que já existia no restante da linha.

Esta última é proveniente dos `fetchHelpers` e recebe o _endpoint_ (endereço) `${config.fetchApi.prod}/alunos` localizado no `config`, realiza um `post`, é do tipo `application/json` e envia no corpo da requisição um `JSON.stringify()` do nosso objeto `aluno`.

```javascript
const chamadaApi = await fetchApi(`${config.fetchApi.prod}/alunos`, 'POST', 'application/json', JSON.stringify(aluno));
```

Nos _logs_ do _Serverless_ verificamos que, apesar da propriedade `body` ser um objeto, ela está entre aspas — ou seja, já é uma string. Isso torna o `JSON.stringify()` desnecessário para enviar o `aluno` via HTTP, portanto, vamos removê-lo.

```javascript
const chamadaApi = await fetchApi(`${config.fetchApi.prod}/alunos`, 'POST', 'application/json', aluno);
```

Na linha abaixo da atual, há um `Promise.all()`. Considerando que não utilizaremos mais o arranjo de Promessas, removeremos toda essa linha.

Toda requisição HTTP precisa de uma resposta, portanto, adicionaremos abaixo da linha `const chamadaApi` uma `const res`, onde `res` significa "resposta". Ela receberá outra função de `fetchHelpers`, denominada `buildResponse()`. Vamos importá-la na linha 2, entre as chaves e à direita de `fetchApi`.

```javascript
const { fetchApi, buildResponse } = require('../../../utils/fetchHelpers');
```

Esse método receberá dados retornados da requisição e montará um objeto-resposta que será a resposta HTTP.

Voltando à `const res`, ela receberá a `buildResponse()`. Quando abrirmos os parênteses, o editor exibirá uma janela com sugestões dos parâmetros. Veremos que o primeiro é `status` (neste caso, o `statusCode`), por isso, adicionaremos o `chamadaApi.statusCode`.

O segundo parâmetro é o `body` (o corpo da requisição), que será `chamadaApi.body`. O terceiro parâmetro são os `headers` (cabeçalhos), que será `chamadaApi.headers`.

```javascript
        const res = buildResponse (chamadaApi.statusCode, chamadaApi.body, chamadaApi.headers);
```

Com os três, conseguiremos montar e enviar o objeto-resposta.

A última parte desta função consiste em um `if` que verificava se alguma Promessa não havia sido concluída. Vamos removê-la também, pois não será mais necessária.

O código completo do arquivo pode ser visto abaixo.

```javascript
const config = require('../../../config/config.json');
const { fetchApi, buildResponse } = require('../../../utils/fetchHelpers');

module.exports.cadastrarAlunos = async (aluno) => {
    const chamadaApi = await fetchApi(`${config.fetchApi.prod}/alunos`, 'POST', 'application/json', aluno);
        
        const res = buildResponse (chamadaApi.statusCode, chamadaApi.body, chamadaApi.headers);

};
```

Em seu lugar, faremos outra verificação para confirmar que a função funciona. A primeira etapa é envolver todo o conteúdo no interior da função com um bloco `try`, adicionando abaixo deste um bloco `catch (erro){}`.

> **Dica:** Para mover todas as linhas juntas, selecionamos o conteúdo a ser movido e utilizamos o atalho "Alt+seta".

```javascript
module.exports.cadastrarAlunos = async (aluno) => {
    try {
        const chamadaApi = await fetchApi(`${config.fetchApi.prod}/alunos`, 'POST', 'application/json', aluno);
        
        const res = buildResponse (chamadaApi.statusCode, chamadaApi.body, chamadaApi.headers);
        } catch (erro) {
        
        }

};
```

No interior das chaves do `try`, abaixo do conteúdo movido, retornaremos a resposta. Para isso, adicionaremos um `if` para verificar entre parênteses se `res.statusCode` for igual a `201` (correspondente ao recurso criado, conforme esperado). Neste caso, retornaremos um objeto representado por um bloco de chaves e em seu interior, uma `mensagem` com a string `sucesso no cadastro`.

Abaixo de `mensagem`, adicionaremos a propriedade `status: res.statusCode` ao objeto. Com isso, recolheremos a resposta e faremos algo com ela, retornando um objeto.

```javascript
module.exports.cadastrarAlunos = async (aluno) => {
    try {
        const chamadaApi = await fetchApi(`${config.fetchApi.prod}/alunos`, 'POST', 'application/json', aluno);
        
        const res = buildResponse (chamadaApi.statusCode, chamadaApi.body, chamadaApi.headers);
        
        if (ress.statusCode === 201) {
            return {
                mensagem: 'sucesso no cadastro',
                status: res.statusCode
            };
        }

    } catch (erro) {

    }

};
```

Para os casos em que houver retorno de outro _status_ que não o `201` passaremos abaixo das chaves do `if` a mensagem genérica `mensagem: 'outros status'` dentro de um `return {}`. Posteriormente, trabalharemos melhor com essa mensagem.

Abaixo de `mensagem`, adicionaremos também o `res.statusCode` para verificar o _status_ recebido.

No interior das chaves do `catch`, por enquanto, adicionaremos um `console.error()` que receberá entre chaves um `erro` para verificarmos nos _logs_ do Serverless possíveis problemas.

```javascript
module.exports.cadastrarAlunos = async (aluno) => {
    try {
        const chamadaApi = await fetchApi(`${config.fetchApi.prod}/alunos`, 'POST', 'application/json', aluno);
        
        const res = buildResponse (chamadaApi.statusCode, chamadaApi.body, chamadaApi.headers);
        
        if (ress.statusCode === 201) {
            return {
                mensagem: 'sucesso no cadastro',
                status: res.statusCode
            };
        }
        
        return {
            mensagem: 'outros status',
            status: res.statusCode
        };

    } catch (erro) {
        console.error(erro);
    }

};
```

Conectaremos a função `cadastrarAlunos()` ao `cadastroConsumer()`, pois este será chamado como gatilho do Serverless e enviará o objeto da mensagem do Consumer para o interior daquela.

Para isso, acessaremos o arquivo `cadastroConsumer.js`. Em seu interior, manteremos o `console.log()`, por enquanto. Abaixo dele, chamaremos nossa função criando um bloco `try` e `catch(erro)`.

No interior das chaves do `try`, extrairemos do evento o `body` visto no _log_. Para isso, criaremos uma `const`, enviando o `body` entre chaves para desconstruir o objeto e recolher a propriedade mencionada.

Este receberá um `evento.Records` (com "R" maiúsculo) no índice `[0]`. Conforme visto no _log_, ele é sempre um arranjo. Visto que trabalharemos com um item de `aluno` por vez, ele trará somente um índice.

A partir desse `body`, finalmente ligaremos o Consumer à função `cadastrarAlunos()`. Para isso, criaremos a importação do serviço `alunos` no topo do arquivo atual, por meio de uma `const { cadastrarAlunos } = require('../cadastroAlunos/cadastrarAlunos')`, onde saímos da pasta atual e acessamos o caminho "cadastroAlunos > cadastrarAlunos", passando-o como parâmetro de `require`.

```javascript
const { cadastrarAlunos } cadastrarAlunos ');| I = require('../cadastroAlunos/

module.exports.cadastroConsumer = async (evento) => {

// Código omitido

};
```

Na função `cadastroConsumer()`, no interior das chaves do `try`, logo abaixo da `const { body }`, adicionaremos um `return` que chamará a função `cadastrarAlunos()`, recebendo entre parênteses `body` (nosso objeto com nome e e-mail de cada pessoa aluna).

No interior das chaves do `catch`, enviaremos, por enquanto, somente um `console.error()` com a mensagem `falha no envio para cadastro` entre aspas simples.

Abaixo deste, criaremos outro `console.error()` substituindo a mensagem pelo objeto `erro` que será recebido via parâmetro nos casos de problemas no `catch`.

```
const { cadastrarAlunos } = require('../cadastroAlunos/cadastrarAlunos');

module.exports.cadastroConsumer = async (evento) => {
  console.log('DADOS EVENTO DO CONSUMER', evento);

  try {
    const { body } = evento.Records[0];
    return cadastrarAlunos(body);
  } catch (erro) {
    console.error('falha no envio para cadastro');
    throw erro;
  }
};
```

A seguir, realizaremos um _deploy_ para testar nossa aplicação.