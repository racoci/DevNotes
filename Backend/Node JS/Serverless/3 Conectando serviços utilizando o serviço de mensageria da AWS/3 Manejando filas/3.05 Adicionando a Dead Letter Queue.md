# 3.05 Adicionando a Dead Letter Queue

Nossa aplicação funciona, mas somente no "caminho feliz". Nós a testamos com poucos registros — nosso CSV possui três ou quatro linhas. Contudo, a funcionalidade foi pensada para mais registros.

Vamos verificar o que acontecerá quando o CSV tiver muitos registros e a fila começar a receber muitas pessoas alunas. Buscaremos responder às questões abaixo:

- Será que os itens se acumularão?
- Quantos itens poderão entrar na fila?
- Como ocorre o processamento da fila pelo Consumer?
- Como garantiremos o processamento de todos os itens da fila e o que faremos se isso não acontecer?

Vamos imaginar a mensageria como um serviço de correio. Estes enviam mensagens de um local a outro. Considerando a quantidade de informações que se deslocam, é possível prever que algumas poderão não ser entregues com sucesso.

Podem acontecer problemas no processamento e recebimento de mensagens quando há, por exemplo:

- Mudanças de estado inesperadas em casos de aplicações grandes conectadas a vários serviços
- Mensagens que referenciam o ID de um produto deletado um serviço não conectado
- Partes do produto fora do ar

O serviço de mensagens deve saber como lidar com as "cartas" que não foram entregues. Devemos descartá-las?

As mensagerias, por meio de serviços como o Amazon SQS ou RabbitMQ, trabalham com a ferramenta _Dead Letter Queue_ (Fila de cartas mortas) ou simplesmente DQL.

As DLQs são utilizadas para capturar mensagens que não são entregues da fila para o Consumer designado, por qualquer motivo que seja. Podemos delimitar que cada fila de cadastro, por exemplo, tenha uma DLQ associada a si para receber as mensagens não entregues de uma fila específica.

Se, por exemplo, em nossa fila de pessoas alunas para cadastro, uma mensagem de cadastro escapar e não ser entregue, ela será direcionada para essa fila DLQ.

Com isso, podemos comandar o serviço de filas para que mensagens não processadas não se percam ou sejam deletadas automaticamente pelo Serverless e pelo SQS como ocorre com mensagens de sucesso.

Com uma fila específica, nós que cuidamos da aplicação faremos uma "triagem" para decidir o que fazer com as "cartas" não entregues. Já as mensagens bem sucedidas continuarão sendo consumidas e entregues normalmente.

Vamos ver como essa triagem funcionará no código. Como mencionado anteriormente, podemos criar uma DLQ pelo console da Amazon SQS. Para isso, voltaríamos a acessar essa página pelo navegador, aberta na seção "_Queues_", e clicaríamos no botão "_Create Queue_" (Criar fila).

Entretanto, realizar esse processo manualmente não é interessante para nós, visto a necessidade de conceder inúmeras permissões também manualmente.

Já que nosso foco é o Serverless, vamos realizar essa etapa nele.

Vamos refletir sobre como criamos a fila de cadastro. Nós criamos um recurso, demos permissões a eles e os associamos ao gatilho de uma função.

Retornando ao VSC, acessaremos o arquivo `serverless.yml` e em seu interior, buscaremos a seção `Resources`. Nela, temos uma `FilaCadastro`.

```javascript
Resources:
    FilaCadastro:
        Type: AWS: :SQS:: Queue
        Properties:
            QueueName: cadastro.fifo
            FifoQueue: true
            SqsManaged SseEnabled: false
```

As filas DLQ, a princício, funcionam como qualquer outra fila (incluindo as de sucesso), portanto, vamos duplicar os dados da seção `Resources` abaixo de si mesma, a partir da linha `FilaCadastro`.

Nos dados duplicados, faremos as seguintes substituições:

- Alteraremos o nome do recurso de `FilaCadastro` para `DlqCadastro`
- Alteraremos o nome da fila (`QueueName`) de `cadastro.fifo` para `cadastro-dlq.fifo`

```javascript
Resources:
    FilaCadastro:
        Type: AWS: :SQS:: Queue
        Properties:
            QueueName: cadastro.fifo
            FifoQueue: true
            SqsManaged SseEnabled: false
    DlqCadastro:
        Type: AWS: :SQS:: Queue
        Properties:
            QueueName: cadastro-dlq.fifo
            FifoQueue: true
            SqsManaged SseEnabled: false
```

> **Observação:** Filas DQL devem servir sempre à filas do mesmo tipo. Se a fila original for _standard_, por exemplo, a sua DQL também deve ser _standard_.

A fila DQL foi criada. Como informamos ao Serverless que a `DlqCadastro` servirá como "fila de cartas mortas" da `FilaCadastro`? Voltaremos ao bloco da `FilaCadastro` e criaremos a propriedade `RedrivePolicy` abaixo de `SqsManaged SseEnabled: false`.

Pressionaremos "Enter" para adicionar a propriedade `deadLetterTargetArn:` dentro do bloco `RedrivePolicy`, onde ARN é o nome de recurso da Amazon. Pressionaremos mais um "Enter" e adicionaremos a função `Fn::GetAtt:` dentro do bloco `deadLetterTargetArn:`, onde `Att` é atributo.

Pressionaremos "Enter" mais uma vez e adicionaremos um traço para incluir dois itens de lista, um abaixo do outro, dentro da função `Fn::GetAtt:`:

- O nome da fila DQL alvo de `FilaCadastro` — ou seja, a `DlqCadastro`
- A `Arn`.

Com isso, elas estão associadas. Ele recolherá o nome de recurso do `DlqCadastro` e enviará para o interior de `FilaCadastro`, pois uma é DLQ da outra.

Abaixo dos dois itens de lista, incluiremos em `FilaCadastro` mais duas informações importantes associadas à DLQ.

- Na mesma hierarquia de `deadLetterTargetArn`, adicionaremos o `maxReceiveCount:` que receberá o número `5`
- Na mesma hierarquia de `RedrivePolicy`, adicionaremos o `VisibilityTimeout:` (com V maiúsculo) que receberá o número `10`

Entenderemos esses números "mágicos" posteriormente.

```javascript
Resources:
    FilaCadastro:
        Type: AWS::SQS::Queue
        Properties:
            QueueName: cadastro.fifo
            FifoQueue: true
            SqsManaged SseEnabled: false
            RedrivePolicy:
                deadLetterTargetArn:
                    Fn::GetAtt:
                        - DlqCadastro
                        - Arn
                maxReceiveCount: 5
            VisibilityTimeout: 10
    DlqCadastro:
        Type: AWS: :SQS:: Queue
        Properties:
            QueueName: cadastro-dlq.fifo
            FifoQueue: true
            SqsManaged SseEnabled: false
```

Disponibilizaremos nas atividades desta aula uma lista da AWS com essas e outras propriedades que podemos adicionar.

O `RedrivePolicy` consiste em uma "política de retentativas".

A AWS recomenta que, no lugar de envios instantâneos para a fila DLQ, o SQS realize, no mínimo, 5 tentativas de entrega para a fila principal nos casos em que a função retornar um erro de consumo. O número `5` adicionado em `maxReceiveCount` refere-se a esse número de tentativas.

Quando trabalhamos com elementos distribuídos, algum deles pode ficar fora do ar momentaneamente. Nestes casos, se houver outra tentativa, o envio poderá ser bem-sucedido. Isso é similar aos momentos em que recarregamos a página exaustivamente até carregá-la.

Vamos descer o arquivo atual até a função principal `cadastroConsumer`, na qual a `FilaCadastro` é chamada. Nada mudará na função em si. Ela continuará conhecendo apenas a `FilaCadastro`.

Neste caso, em que momento as mensagens irão para a DLQ, considerando que a função `cadastroConsumer` não será avisada? Isso será feito após as 5 tentativas de entrega especificadas.

Entretanto, quando será que uma tentativa de entrega é efetuada? Como isso funciona?

É aqui que entra o `VisibilityTimeout`. Ele recebe um número em segundos que representa a quantidade de tempo que o sistema esperará antes de realizar uma nova tentativa. O valor mínimo é 0 e o padrão é 30 segundos. O máximo, por sua vez, são 12 horas.

Nós configuramos em 10 segundos. O cálculo utilizado para chegar neste número será abordado posteriormente.

Se configuramos 5 tentativas para cada 10 segundos, o processo completo ocorrerá em 40 segundos (a primeira tentativa é realizada de maneira imediata).

Se não for possível realizar a entrega da mensagem em 5 tentativas, ela será enviada para a DLQ que forçará a mensagem a ser lida.

Resumindo, adicionamos a DLQ, uma ferramenta para nos auxiliar a lidar com erros. A associação desta com a fila principal será também gerenciada pelo Serverless.

A seguir, implementaremos as ações a serem realizadas após recebermos as mensagens na DLQ.