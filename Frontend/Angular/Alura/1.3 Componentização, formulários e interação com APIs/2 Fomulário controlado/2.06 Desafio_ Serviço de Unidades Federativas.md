# 06 Desafio: ServiÃ§o de Unidades Federativas

Chegou a sua hora da aventura, parte 2! NÃ³s jÃ¡ sabemos como criar serviÃ§os que obtÃªm dados da API. Agora, precisamos de um novo serviÃ§o que vai buscar os estados brasileiros.

Essa aventura Ã© ousada, entÃ£o queria aproveitar esse momento para pensarmos em otimizaÃ§Ã£o. Precisamos de uma camada de cache para evitar chamadas desnecessÃ¡rias Ã  API, porque a lista de unidades federativas nÃ£o Ã© algo que muda com muita frequÃªncia, nÃ£o Ã© mesmo?

De maneira simples,Â `shareReplay`Â Ã© um operadorÂ **RxJS**Â que, ao ser combinado com o mÃ©todoÂ `pipe`, nos permite armazenar em cache o resultado de umÂ **Observable**. Isso nos permite fazer exatamente o que queremos aqui: evitar requisiÃ§Ãµes HTTP desnecessÃ¡rias. Uma vez que os dados jÃ¡ foram buscados, eles ficam guardadinhos esperando para serem reutilizados, o que Ã© um salva-vidas quando a ideia Ã© otimizar o desempenho da aplicaÃ§Ã£o.

Agora, se vocÃª quiser dar um mergulho ainda mais profundo nessa histÃ³ria toda deÂ `shareReplay`, dÃ¡ uma passada naÂ [documentaÃ§Ã£o oficial](https://rxjs.dev/api/operators/shareReplay). LÃ¡ tem uma galera que sabe das coisas e pode te dar mais detalhes de como isso funciona por debaixo dos panos.

Bora de cÃ³digo? Hora de implementar o nosso serviÃ§o, tomando aquele cuidado especial com a camada de cache. DÃ¡ uma olhada em como ficou o meu resultado:

```ts
import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable, shareReplay } from 'rxjs';
import { environment } from 'src/environments/environment';
import { UnidadeFederativa } from '../types/type';

@Injectable({
  providedIn: 'root'
})
export class UnidadeFederativaService {
  private apiUrl: string = environment.apiUrl
  private cache$?: Observable<UnidadeFederativa[]>;

  constructor(
    private http: HttpClient
  ) { 
  }

  listar() : Observable<UnidadeFederativa[]> {
    if (!this.cache$) {
      this.cache$ = this.requestEstados().pipe(
        shareReplay(1)
      );
    }

    return this.cache$;
  }

  private requestEstados(): Observable<UnidadeFederativa[]> {
    return this.http.get<UnidadeFederativa[]>(`${this.apiUrl}/estados`);
  }
}
```

Primeiro, os detalhes mais administrativos: a classeÂ `UnidadeFederativaService`Â Ã© uma injeÃ§Ã£o de dependÃªnciaÂ `@Injectable`Â fornecida no escopo 'root', o que quer dizer que ela Ã© instanciada uma Ãºnica vez durante todo o ciclo de vida do app. O Angular Ã© cheio desses truques Jedi, e lembre-se que temos um â€œpara saber maisâ€ falando exatamente sobre na aula anterior!

![https://media.tenor.com/buuh81xjVgEAAAAC/ahsoka-tano.gif](https://cdn3.gnarususercontent.com.br/3151-angular-layout-componentizacao/2.gif)

Dentro do nosso serviÃ§o, nÃ³s temos a variÃ¡velÂ `apiUrl`Â que guarda a URL base da API - sacada diretamente das variÃ¡veis de ambiente. TambÃ©m temos aÂ `cache$`, uma variÃ¡vel opcional que vai guardar umÂ **Observable**Â de um array deÂ **UnidadeFederativa**.

A mÃ¡gica comeÃ§a no mÃ©todoÂ `listar()`. Quando chamado, ele checa se jÃ¡ existe algo na nossaÂ `cache$`. Se nÃ£o tiver nada lÃ¡, ele chama o mÃ©todoÂ `requestEstados()`, que faz uma requisiÃ§Ã£oÂ **GET**Â para a rota '/estados' da nossa API. A resposta dessa requisiÃ§Ã£o Ã© entÃ£o armazenada naÂ `cache$`Â com o uso do operadorÂ `shareReplay`, que faz com que o valor buscado fique guardado para futuras subscriÃ§Ãµes.

Agora, toda vez que chamarmosÂ `listar()`, se jÃ¡ tivermos uma resposta armazenada naÂ `cache$`, ela Ã© retornada direto, evitando uma nova requisiÃ§Ã£o HTTP. Uma maravilha para a performance, como se tivÃ©ssemos o prÃ³prio Yoda otimizando nosso cÃ³digo!

E Ã© basicamente isso que esse cÃ³digo estÃ¡ fazendo. Lembra que mencionei antes sobre a documentaÃ§Ã£o oficial do RxJS? Vale a pena dar uma olhada lÃ¡ para entender ainda mais sobre esse operador incrÃ­vel.

Se tiver mais alguma dÃºvida, conte comigo. E que a ForÃ§a esteja com vocÃª, sempre! ğŸ˜‰
