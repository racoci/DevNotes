# 694. Exploring Selectors

> Duração: `8min`

## Recursos
- 09-selectors.zip
- 09-selectors-standalone.zip

WEBVTT

1
00:00:02.040 --> 00:00:03.640
<v Maximilian>Now with that,</v>

2
00:00:03.640 --> 00:00:06.510
we're almost done with this introduction to NgRx.

3
00:00:06.510 --> 00:00:09.150
I now just also wanna explore selectors

4
00:00:09.150 --> 00:00:10.380
and then thereafter.

5
00:00:10.380 --> 00:00:14.460
To really conclude this introduction, I also wanna dive

6
00:00:14.460 --> 00:00:17.700
into effects and show you what effects are all about.

7
00:00:17.700 --> 00:00:20.010
But let's start with selectors.

8
00:00:20.010 --> 00:00:22.014
What are selectors?

9
00:00:22.014 --> 00:00:26.160
Well, as you learned before in this application here,

10
00:00:26.160 --> 00:00:28.890
you can select data from the store

11
00:00:28.890 --> 00:00:31.560
like here in the counter output component

12
00:00:31.560 --> 00:00:33.660
with help of the select method.

13
00:00:33.660 --> 00:00:36.480
And here I'm simply selecting the entire state slice

14
00:00:36.480 --> 00:00:39.330
or the entire counter, which in my case here

15
00:00:39.330 --> 00:00:41.640
is simply the counter number then.

16
00:00:41.640 --> 00:00:45.450
And I get back an observable to which I can listen.

17
00:00:45.450 --> 00:00:48.474
In this case here with the async pipe, for example.

18
00:00:48.474 --> 00:00:52.133
Now that's all straightforward and absolutely fine

19
00:00:52.133 --> 00:00:56.580
but there is an alternative or, to be precise

20
00:00:56.580 --> 00:01:00.530
an addition, to this way of selecting values.

21
00:01:00.530 --> 00:01:03.210
Because whilst this can be nice

22
00:01:03.210 --> 00:01:06.120
for getting the entire state as it's stored

23
00:01:06.120 --> 00:01:09.900
in the store for a specific slice of the store,

24
00:01:09.900 --> 00:01:12.869
there also can be scenarios and use cases where

25
00:01:12.869 --> 00:01:16.650
you maybe wanna transform the data that's stored

26
00:01:16.650 --> 00:01:18.660
in the store before you output it.

27
00:01:18.660 --> 00:01:20.826
And that's what I wanna show you now.

28
00:01:20.826 --> 00:01:23.730
For that, in that store folder, I'll add a new file

29
00:01:23.730 --> 00:01:26.283
counter selectors.ts.

30
00:01:27.214 --> 00:01:31.620
And I wanted to find all my extra selectors in that file.

31
00:01:31.620 --> 00:01:32.805
So what's a selector?

32
00:01:32.805 --> 00:01:36.810
A selector in its simplest form, is a function

33
00:01:36.810 --> 00:01:39.570
that could be stored in a constant, select count

34
00:01:39.570 --> 00:01:40.403
for example.

35
00:01:40.403 --> 00:01:43.045
And then here I'm storing an arrow function.

36
00:01:43.045 --> 00:01:48.045
This selector function will then get a state value

37
00:01:48.442 --> 00:01:52.505
which is the overall NgRx store state.

38
00:01:52.505 --> 00:01:56.460
And therefore the shape of that state is the shape

39
00:01:56.460 --> 00:01:57.723
of your overall store.

40
00:01:58.710 --> 00:02:02.700
In this demo application here, that would be an object

41
00:02:02.700 --> 00:02:05.880
that has all the keys you defined here when you

42
00:02:05.880 --> 00:02:07.500
registered the store.

43
00:02:07.500 --> 00:02:10.399
And under those keys, you will find the different values

44
00:02:10.399 --> 00:02:14.202
stored for these different state slices, you could say.

45
00:02:14.202 --> 00:02:17.621
So for example, a number for the counter reducer.

46
00:02:17.621 --> 00:02:21.516
Therefore here the shape is an object, which has

47
00:02:21.516 --> 00:02:24.840
for example, this counter key.

48
00:02:24.840 --> 00:02:27.420
And the value will be a number because our counter

49
00:02:27.420 --> 00:02:29.514
state is a number.

50
00:02:29.514 --> 00:02:34.320
And if you used different key here, instead of counter

51
00:02:34.320 --> 00:02:37.440
you used count, for example, you would have to

52
00:02:37.440 --> 00:02:39.213
use that different key here.

53
00:02:40.350 --> 00:02:43.533
But here, I'll stick to counter and revert this.

54
00:02:44.670 --> 00:02:49.140
If you had more keys here, you could add them all as keys

55
00:02:49.140 --> 00:02:53.700
to this type here for this state and this selector.

56
00:02:53.700 --> 00:02:56.760
But here I need only care about this counter state slice.

57
00:02:56.760 --> 00:02:59.850
And I only have that counter state slice here.

58
00:02:59.850 --> 00:03:01.810
That's why I'm defining the shape

59
00:03:02.661 --> 00:03:06.116
of my overall store state like this here in this selector.

60
00:03:06.116 --> 00:03:09.570
And then in this arrow function for this selector,

61
00:03:09.570 --> 00:03:12.000
you simply return the value you wanna select.

62
00:03:12.000 --> 00:03:14.160
In this case, for example, state counter

63
00:03:14.160 --> 00:03:16.710
so that you get the unchanged counter

64
00:03:16.710 --> 00:03:18.636
as it's stored in the store.

65
00:03:18.636 --> 00:03:21.714
That's how you can define a selector.

66
00:03:21.714 --> 00:03:25.679
Now, with such a selector defined, you can then export it

67
00:03:25.679 --> 00:03:29.340
so that it can be used in other parts of the app.

68
00:03:29.340 --> 00:03:32.910
And you then might wanna use this inside of other services

69
00:03:32.910 --> 00:03:35.999
or Components where you need data from the store.

70
00:03:35.999 --> 00:03:39.018
For example, here in the counter output component,

71
00:03:39.018 --> 00:03:43.098
you could now use select count by importing it

72
00:03:43.098 --> 00:03:46.470
from that counter selector's file and use that

73
00:03:46.470 --> 00:03:49.960
as a value for the select method on that store.

74
00:03:49.960 --> 00:03:53.861
So instead of just defining the key here

75
00:03:53.861 --> 00:03:57.570
of the state slice you wanna select here,

76
00:03:57.570 --> 00:04:01.018
you can also pass a selector function as a value.

77
00:04:01.018 --> 00:04:05.962
And why would you do that instead of just defining the key?

78
00:04:05.962 --> 00:04:09.960
Well, because especially in more complex applications

79
00:04:09.960 --> 00:04:12.690
you of course might have different Components

80
00:04:12.690 --> 00:04:16.080
or services that need to access the same data

81
00:04:16.080 --> 00:04:17.430
from your store.

82
00:04:17.430 --> 00:04:20.280
And having one central place where you then

83
00:04:20.280 --> 00:04:23.722
define the selection logic could be a good thing to have

84
00:04:23.722 --> 00:04:27.360
because if you then ever change that key here,

85
00:04:27.360 --> 00:04:30.639
or you change that state value selection logic

86
00:04:30.639 --> 00:04:33.900
you just have to do it in one place instead

87
00:04:33.900 --> 00:04:36.421
of going to multiple Components or services.

88
00:04:36.421 --> 00:04:40.341
And of course, you can also define multiple selectors here.

89
00:04:40.341 --> 00:04:41.700
We could, for example

90
00:04:41.700 --> 00:04:46.075
create a never selector called select double count

91
00:04:46.075 --> 00:04:48.776
which gives us the counter times two.

92
00:04:48.776 --> 00:04:53.018
We could define this selector like this

93
00:04:53.018 --> 00:04:57.802
but you can also use a never nice feature offered by NgRx

94
00:04:57.802 --> 00:05:01.920
which allows you to combine multiple selectors

95
00:05:01.920 --> 00:05:04.938
and which allows you to build new selectors based

96
00:05:04.938 --> 00:05:07.654
on already existing selectors.

97
00:05:07.654 --> 00:05:12.654
You can do this with NgRx's, create selector function

98
00:05:13.620 --> 00:05:16.614
which must be imported from NgRx store.

99
00:05:16.614 --> 00:05:20.790
And this function then accepts a list of arguments

100
00:05:20.790 --> 00:05:24.033
where every argument is such a selector function.

101
00:05:25.020 --> 00:05:28.230
So you could pass the existing select count function

102
00:05:28.230 --> 00:05:31.343
as a first argument, and then you could pass a never

103
00:05:31.343 --> 00:05:34.920
state selection function as a second argument.

104
00:05:34.920 --> 00:05:38.040
And the input for this second argument function here

105
00:05:38.040 --> 00:05:41.640
will be the return value of this first function.

106
00:05:41.640 --> 00:05:45.660
So in this case here simply a number, because here

107
00:05:45.660 --> 00:05:48.090
we get the selected state as it was selected

108
00:05:48.090 --> 00:05:49.650
by this first argument.

109
00:05:49.650 --> 00:05:52.959
And here I returned the state counter, which is a number.

110
00:05:52.959 --> 00:05:57.150
You don't even need to add that type annotation because

111
00:05:57.150 --> 00:05:58.890
TypeScript is indeed able to infer

112
00:05:58.890 --> 00:06:02.430
that the value returned by this function will be a number.

113
00:06:02.430 --> 00:06:05.310
And then here you could return state times two,

114
00:06:05.310 --> 00:06:07.200
giving you an even shorter way

115
00:06:07.200 --> 00:06:10.079
of defining this selector function.

116
00:06:10.079 --> 00:06:14.280
And that's how you could build more complex selector

117
00:06:14.280 --> 00:06:18.210
functions by layering different selector functions

118
00:06:18.210 --> 00:06:19.301
on top of each other.

119
00:06:19.301 --> 00:06:22.599
And now you could also use this selector function

120
00:06:22.599 --> 00:06:25.440
in a component that needs that state.

121
00:06:25.440 --> 00:06:27.946
For example, the counter output component again.

122
00:06:27.946 --> 00:06:31.302
There we could add a never observable,

123
00:06:31.302 --> 00:06:35.280
the double count observable, let's say, which still

124
00:06:35.280 --> 00:06:39.090
will be an observable that ultimately yields a number.

125
00:06:39.090 --> 00:06:40.410
But then here in the constructor

126
00:06:40.410 --> 00:06:43.487
we can set double count equal to store select

127
00:06:43.487 --> 00:06:47.183
and set that equal to select double count

128
00:06:47.183 --> 00:06:49.740
which of course also must be imported

129
00:06:49.740 --> 00:06:52.526
from the counter selectors file therefore.

130
00:06:52.526 --> 00:06:56.063
But that's how you can then use selectors.

131
00:06:56.063 --> 00:06:59.640
And now for this component, we could also go

132
00:06:59.640 --> 00:07:02.905
to the template file and also bring back that double counter

133
00:07:02.905 --> 00:07:07.905
by outputting double count with help of the async pipe here.

134
00:07:10.200 --> 00:07:13.865
And with that, if you now serve this application here

135
00:07:13.865 --> 00:07:17.970
you see that we now have two counters and that

136
00:07:17.970 --> 00:07:22.290
the bottom counter is indeed double the first counter.

137
00:07:22.290 --> 00:07:26.730
And they're all based on the same globally managed store.

138
00:07:26.730 --> 00:07:28.543
And of course, as always,

139
00:07:28.543 --> 00:07:32.220
this works no matter how you're building your application.

140
00:07:32.220 --> 00:07:34.320
If you're using Standalone Components

141
00:07:34.320 --> 00:07:37.145
you can also output the double counter there.

142
00:07:37.145 --> 00:07:42.145
And of course, add it to this component like this.

143
00:07:43.350 --> 00:07:47.043
So to the counter output component, add it like this,

144
00:07:48.390 --> 00:07:51.240
and then make sure that you also add the selectors there.

145
00:07:51.240 --> 00:07:53.760
So copy that counter selector.ts file

146
00:07:53.760 --> 00:07:55.263
into the store folder,

147
00:07:57.300 --> 00:08:00.150
and make sure that you have these selector imports

148
00:08:00.150 --> 00:08:02.869
in the component or in the service

149
00:08:02.869 --> 00:08:04.500
that uses those selectors.

150
00:08:04.500 --> 00:08:06.570
And that's by the way, all important.

151
00:08:06.570 --> 00:08:10.380
You can use selectors and you can also dispatch actions

152
00:08:10.380 --> 00:08:12.390
not just inside of Components,

153
00:08:12.390 --> 00:08:15.333
but also from inside services, if you want to.

