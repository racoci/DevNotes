# 32. Using Signal Inputs

> Duração: `14min`

Sem Recursos

WEBVTT

0
00:00.330 --> 00:04.290
<v Maximilian>So this is how you can accept inputs</v>

1
00:04.290 --> 00:05.610
in your components.

2
00:05.610 --> 00:10.284
So properties or custom attributes, you could say,

3
00:10.284 --> 00:13.080
you can set on your own components

4
00:13.080 --> 00:15.330
to pass data into them.

5
00:15.330 --> 00:18.300
Now, earlier in this section,

6
00:18.300 --> 00:23.280
I showed you an alternative way of managing state.

7
00:23.280 --> 00:26.508
So of managing data that may change over time

8
00:26.508 --> 00:30.633
and where those changes should then be reflected in the UI.

9
00:31.470 --> 00:34.650
And that alternative modern approach

10
00:34.650 --> 00:39.330
offered by Angular works with so-called signals.

11
00:39.330 --> 00:43.890
Now it turns out that you can also use signals

12
00:43.890 --> 00:45.930
for accepting inputs

13
00:45.930 --> 00:49.770
instead of using this @Input decorator.

14
00:49.770 --> 00:52.230
And therefore, I also want to introduce you

15
00:52.230 --> 00:56.100
to how you would accept inputs with signals

16
00:56.100 --> 00:58.950
so that you do know about both approaches.

17
00:58.950 --> 01:01.560
And of course, you'll then also see both approaches

18
01:01.560 --> 01:04.020
in action throughout this course.

19
01:04.020 --> 01:06.510
Now to accept an Input as a signal,

20
01:06.510 --> 01:10.410
you start by importing the input function

21
01:10.410 --> 01:12.570
from @angular/core.

22
01:12.570 --> 01:14.596
input with a lowercase I.

23
01:14.596 --> 01:16.740
That's important.

24
01:16.740 --> 01:19.710
With an uppercase, it's that decorator;

25
01:19.710 --> 01:22.473
with a lowercase, it's a special function.

26
01:23.910 --> 01:25.618
Now with that imported,

27
01:25.618 --> 01:29.850
you can then replace these inputs here

28
01:29.850 --> 01:31.957
by still adding properties

29
01:31.957 --> 01:33.540
with the intended names

30
01:33.540 --> 01:36.270
like avatar as we did it before.

31
01:36.270 --> 01:39.150
But instead of adding a decorator in front of them,

32
01:39.150 --> 01:41.040
you now assign a value

33
01:41.040 --> 01:45.000
and initial value to these properties.

34
01:45.000 --> 01:47.910
And that value is the result of calling

35
01:47.910 --> 01:49.473
that input function.

36
01:50.400 --> 01:52.980
That internally tells Angular

37
01:52.980 --> 01:54.990
that this avatar property

38
01:54.990 --> 01:57.600
should be an input to this component

39
01:57.600 --> 02:00.224
so that it should be set as an attribute

40
02:00.224 --> 02:02.613
when that component is used.

41
02:05.310 --> 02:07.830
Now that's not all you typically do

42
02:07.830 --> 02:10.350
with that input function though.

43
02:10.350 --> 02:13.710
Instead, you can also assign a default value,

44
02:13.710 --> 02:16.320
which will be assumed if no input value

45
02:16.320 --> 02:17.910
has been received yet,

46
02:17.910 --> 02:20.253
which could, for example, be an empty string.

47
02:21.690 --> 02:25.830
Alternatively, you can also not pass an initial value,

48
02:25.830 --> 02:29.286
and therefore the initial value would be undefined.

49
02:29.286 --> 02:32.910
But you can tell TypeScript in the end,

50
02:32.910 --> 02:36.870
and therefore implicitly of course also Angular

51
02:36.870 --> 02:40.440
that eventually a value of a different type

52
02:40.440 --> 02:41.310
will be received.

53
02:41.310 --> 02:45.330
For example, here, that eventually a string will be received

54
02:45.330 --> 02:49.706
by adding angle brackets after this input function name,

55
02:49.706 --> 02:51.873
but before the parentheses.

56
02:52.710 --> 02:54.600
And between those angle brackets,

57
02:54.600 --> 02:57.240
you can set the type of value

58
02:57.240 --> 03:00.783
that will eventually be by that input.

59
03:02.400 --> 03:05.130
Now this angle bracket syntax here

60
03:05.130 --> 03:09.270
is not some Angular specific syntax,

61
03:09.270 --> 03:11.382
instead that's a TypeScript thing.

62
03:11.382 --> 03:15.720
It's a so-called generic type we're dealing with here.

63
03:15.720 --> 03:20.490
input, the input function is a generic function

64
03:20.490 --> 03:23.640
set up to be generic by the Angular team,

65
03:23.640 --> 03:25.920
which in the end means it's a function

66
03:25.920 --> 03:30.920
that's able to work with a broad variety of value types,

67
03:30.990 --> 03:35.940
a broad variety of input value types in this case here.

68
03:35.940 --> 03:38.790
And with that angle bracket syntax,

69
03:38.790 --> 03:41.237
we simply tell TypeScript

70
03:41.237 --> 03:46.140
which kind of value will eventually be received

71
03:46.140 --> 03:47.640
by that input.

72
03:47.640 --> 03:50.580
And that then can help us further down the road

73
03:50.580 --> 03:52.920
when we work with that input value.

74
03:52.920 --> 03:56.250
So when we work with this avatar property,

75
03:56.250 --> 03:59.250
because TypeScript then will know

76
03:59.250 --> 04:01.500
that this avatar property

77
04:01.500 --> 04:04.650
will hold a signal in the end,

78
04:04.650 --> 04:08.880
since input, this input function produces a signal.

79
04:08.880 --> 04:10.260
So a data container,

80
04:10.260 --> 04:12.490
but inside of that data container

81
04:13.534 --> 04:16.050
will eventually have a string value.

82
04:16.050 --> 04:18.702
That's the idea behind this syntax.

83
04:18.702 --> 04:21.240
And you'll see it from time to time

84
04:21.240 --> 04:23.400
when working with TypeScript,

85
04:23.400 --> 04:26.253
not just in Angular projects.

86
04:27.330 --> 04:30.756
You can also mark an input as required

87
04:30.756 --> 04:34.410
by calling input.required.

88
04:34.410 --> 04:38.250
So a modified version of that function, so to say.

89
04:38.250 --> 04:40.620
That's the equivalent of setting required

90
04:40.620 --> 04:42.723
with the @Input decorator.

91
04:43.650 --> 04:45.180
Now when using required,

92
04:45.180 --> 04:48.330
you can't pass an initial value.

93
04:48.330 --> 04:50.190
As you see, I'm getting an arrow here.

94
04:50.190 --> 04:52.440
Because if this input is required,

95
04:52.440 --> 04:55.500
you are telling Angular that it will be set.

96
04:55.500 --> 04:58.410
So an initial value of course makes no sense

97
04:58.410 --> 05:01.530
because there will be a value set

98
05:01.530 --> 05:04.440
from outside of this component anyways.

99
05:04.440 --> 05:05.273
So in that case,

100
05:05.273 --> 05:07.080
you should just tell Angular

101
05:07.080 --> 05:10.020
which kind of value will be set here

102
05:10.020 --> 05:12.603
by using this angle bracket syntax again.

103
05:14.070 --> 05:15.510
And then we could do the same thing

104
05:15.510 --> 05:17.160
with the name input here.

105
05:17.160 --> 05:19.770
With name = input.required,

106
05:19.770 --> 05:22.383
which will also be a string like this.

107
05:24.660 --> 05:27.090
And that's simply an alternative way

108
05:27.090 --> 05:28.530
of accepting inputs

109
05:28.530 --> 05:31.173
instead of using this decorator approach.

110
05:32.220 --> 05:34.680
Now what's really important to understand

111
05:34.680 --> 05:38.130
and keep in mind when setting up inputs like this

112
05:38.130 --> 05:40.740
as signal inputs

113
05:40.740 --> 05:44.520
is that from outside this component,

114
05:44.520 --> 05:47.610
so in this case from inside the app.component,

115
05:47.610 --> 05:49.980
you still use them like before.

116
05:49.980 --> 05:54.660
You still set those inputs with this syntax.

117
05:54.660 --> 05:56.580
So by setting the properties

118
05:56.580 --> 05:58.929
that are marked as inputs as attributes,

119
05:58.929 --> 06:03.929
you could say, on your custom elements,

120
06:03.930 --> 06:06.300
you can still use data binding,

121
06:06.300 --> 06:09.720
property binding to set them to a dynamic value.

122
06:09.720 --> 06:14.520
And that value here also doesn't have to be a signal.

123
06:14.520 --> 06:17.430
Indeed, here in my application,

124
06:17.430 --> 06:19.020
in the app.component,

125
06:19.020 --> 06:22.410
this user's array is a normal array.

126
06:22.410 --> 06:25.830
It's not wrapped in a signal or anything like that.

127
06:25.830 --> 06:29.853
So I'm passing a non signal value as a value

128
06:29.853 --> 06:32.430
to this input signal.

129
06:32.430 --> 06:35.010
And that's really important to understand

130
06:35.010 --> 06:37.500
that from outside this component,

131
06:37.500 --> 06:40.650
it doesn't matter whether your inputs are set up

132
06:40.650 --> 06:44.463
with that input decorator or this input function.

133
06:45.360 --> 06:47.880
Now one advantage we can already see

134
06:47.880 --> 06:51.240
inside of this function where we are using input though,

135
06:51.240 --> 06:53.640
is that we, for example, no longer need

136
06:53.640 --> 06:55.110
that exclamation mark

137
06:55.110 --> 06:57.873
because we're now no longer setting up a property

138
06:57.873 --> 07:01.200
which technically doesn't have an initial value

139
07:01.200 --> 07:03.030
as it was the case here.

140
07:03.030 --> 07:06.120
But instead now from a technical point of view,

141
07:06.120 --> 07:08.036
the avatar and name properties

142
07:08.036 --> 07:10.800
do have values assigned to them.

143
07:10.800 --> 07:14.760
They do have these input signal objects assigned to them,

144
07:14.760 --> 07:17.040
which then will, as you learned,

145
07:17.040 --> 07:19.440
internally hold some other value

146
07:19.440 --> 07:22.140
since they act as data containers

147
07:22.140 --> 07:27.140
and those internal values will be the actual input values.

148
07:27.570 --> 07:30.510
But that's still one nice thing to have

149
07:30.510 --> 07:31.920
that we no longer need

150
07:31.920 --> 07:35.820
to convince TypeScript that we will have values here

151
07:35.820 --> 07:39.303
simply because this code here works in a different way.

152
07:40.890 --> 07:44.940
Well, and since avatar and name now are signals,

153
07:44.940 --> 07:49.230
we can and should now also use them as signals.

154
07:49.230 --> 07:53.220
So in the user component.template file, for example,

155
07:53.220 --> 07:56.880
you now must execute name as a function

156
07:56.880 --> 07:59.820
since that's how you read signal values

157
07:59.820 --> 08:02.520
and how you get Angular to set up that

158
08:02.520 --> 08:05.040
behind the scenes subscription,

159
08:05.040 --> 08:08.733
which does allow it to efficiently update the UI.

160
08:10.500 --> 08:13.050
And we should also change this code here

161
08:13.050 --> 08:15.273
where we calculate the imagePath.

162
08:16.140 --> 08:18.540
Instead of doing it like this with a getter,

163
08:18.540 --> 08:20.340
we can and should now do it

164
08:20.340 --> 08:22.800
with help of the computed function.

165
08:22.800 --> 08:26.536
So imagePath should be a computed value,

166
08:26.536 --> 08:29.789
which is created with help of that computed function

167
08:29.789 --> 08:32.910
that's imported from @angular/core

168
08:32.910 --> 08:36.543
about which you also learned earlier in this section.

169
08:37.710 --> 08:39.270
And this function, as you learned,

170
08:39.270 --> 08:41.460
takes a function as an input,

171
08:41.460 --> 08:44.550
and that function returns to computed value.

172
08:44.550 --> 08:49.290
But we may and typically will now use a signal in there,

173
08:49.290 --> 08:52.020
and we should therefore also call it

174
08:52.020 --> 08:54.997
because that's always how you read signal values.

175
08:54.997 --> 08:57.390
But since I'm now using computed,

176
08:57.390 --> 09:01.680
Angular will only recompute this imagePath value

177
09:01.680 --> 09:05.130
whenever this avatar value here changed.

178
09:05.130 --> 09:08.100
So it's more efficient than what we had before

179
09:08.100 --> 09:09.990
where the getter would be called

180
09:09.990 --> 09:13.863
whenever anything happens to this component, for example.

181
09:15.120 --> 09:16.800
So that's another adjustment

182
09:16.800 --> 09:21.123
we should make when using these signal inputs.

183
09:22.170 --> 09:25.500
Now with that adjustment made imagePath

184
09:25.500 --> 09:29.310
is now also a signal, a computed signal,

185
09:29.310 --> 09:32.460
or a signal that's created with help of computed

186
09:32.460 --> 09:35.640
and they offer in the user.component.html file.

187
09:35.640 --> 09:39.570
You now also must execute imagePath as a function

188
09:39.570 --> 09:41.520
to read that signal value

189
09:41.520 --> 09:44.373
and set up that behind the scenes subscription.

190
09:47.220 --> 09:49.449
Now what's worth noting here

191
09:49.449 --> 09:52.920
is that these input signals,

192
09:52.920 --> 09:56.340
however, are read-only signals,

193
09:56.340 --> 09:59.580
which means they in the end only change

194
09:59.580 --> 10:03.673
or only get new values if the input value

195
10:03.673 --> 10:08.160
outside of this user component changes.

196
10:08.160 --> 10:12.030
So if we would do something here in that app.component

197
10:12.030 --> 10:16.440
that would change the value set on one of those properties,

198
10:16.440 --> 10:18.270
and you will soon see

199
10:18.270 --> 10:20.880
how you could change a value here,

200
10:20.880 --> 10:25.710
then that new value would be received in the user.component,

201
10:25.710 --> 10:27.420
but you can't change the value

202
10:27.420 --> 10:30.360
from inside the user.component.

203
10:30.360 --> 10:34.410
So if here inside of this onSelectUser method,

204
10:34.410 --> 10:38.910
I would decide that I wanna change the avatar value.

205
10:38.910 --> 10:40.230
I can't do this.

206
10:40.230 --> 10:44.850
If I try to call set on this avatar signal here,

207
10:44.850 --> 10:46.560
you see I'm getting an error

208
10:46.560 --> 10:49.893
that this does not exist on that input signal.

209
10:50.760 --> 10:51.960
And you might recall

210
10:51.960 --> 10:53.610
that earlier in the course

211
10:53.610 --> 10:56.190
when I introduced you to signals,

212
10:56.190 --> 10:58.477
you were able to call the set method

213
10:58.477 --> 11:01.623
to set a signal to a new value.

214
11:03.000 --> 11:06.660
Now it does not work here for these input signals,

215
11:06.660 --> 11:10.140
because as I just explained, they are read only.

216
11:10.140 --> 11:13.230
So they can't be changed from inside the component

217
11:13.230 --> 11:15.480
where the inputs are registered.

218
11:15.480 --> 11:18.333
That's just also something to keep in mind.

219
11:19.470 --> 11:21.570
Now the obvious question, of course,

220
11:21.570 --> 11:26.040
therefore is why you would use these inputs here

221
11:26.040 --> 11:30.330
or why you would use the older decorator

222
11:30.330 --> 11:33.494
based approach without signals.

223
11:33.494 --> 11:37.110
Well, and the answer is the same as before

224
11:37.110 --> 11:39.570
when I introduced you to signals.

225
11:39.570 --> 11:41.640
When working with signals,

226
11:41.640 --> 11:44.730
and therefore also when working with signal inputs,

227
11:44.730 --> 11:47.640
you get this advantage that Angular

228
11:47.640 --> 11:50.670
manages these behind the scenes subscriptions

229
11:50.670 --> 11:55.670
and that Angular is able to update the parts of the UI

230
11:56.400 --> 11:58.290
or the values in your code

231
11:58.290 --> 12:03.290
that need updating when such a signal based value changes.

232
12:03.420 --> 12:05.610
So it can be more efficient

233
12:05.610 --> 12:09.150
depending on the rest of your application and so on.

234
12:09.150 --> 12:12.150
Now this efficiency might not always matter

235
12:12.150 --> 12:14.910
because the other older approach

236
12:14.910 --> 12:18.390
without signals is also pretty efficient.

237
12:18.390 --> 12:22.380
But even more importantly, this signal feature

238
12:22.380 --> 12:25.230
and also these signal inputs

239
12:25.230 --> 12:29.490
are a relatively new Angular feature,

240
12:29.490 --> 12:33.150
and therefore many Angular projects out there.

241
12:33.150 --> 12:37.740
Actually, the majority of Angular projects out there,

242
12:37.740 --> 12:40.230
especially in big companies,

243
12:40.230 --> 12:42.715
do not use signals yet

244
12:42.715 --> 12:47.370
or not necessarily use them in the entire code base.

245
12:47.370 --> 12:51.330
Therefore, you will definitely encounter lots of code bases

246
12:51.330 --> 12:56.100
and lots of demos and so on that do not use signals,

247
12:56.100 --> 12:59.970
and that do instead use the Input decorator

248
12:59.970 --> 13:02.760
for accepting component inputs,

249
13:02.760 --> 13:06.210
which is why you should know about both approaches

250
13:06.210 --> 13:09.990
and which is actually why I will not continue

251
13:09.990 --> 13:11.823
with the signals here,

252
13:13.110 --> 13:15.000
why I will delete that code,

253
13:15.000 --> 13:18.393
and why I instead will go back to this decorator

254
13:18.393 --> 13:21.630
based non signal approach,

255
13:21.630 --> 13:23.790
which also means that in the template

256
13:23.790 --> 13:27.903
I no longer call these values as functions.

257
13:29.850 --> 13:31.200
You could use signals,

258
13:31.200 --> 13:33.330
you could use the input function.

259
13:33.330 --> 13:34.920
But for the reasons mentioned,

260
13:34.920 --> 13:37.710
because you'll see plenty of projects

261
13:37.710 --> 13:40.350
that do not use those signals.

262
13:40.350 --> 13:42.480
I'll stick to this code for now.

263
13:42.480 --> 13:44.640
Of course, throughout this course,

264
13:44.640 --> 13:47.370
you will see plenty of signal usage though,

265
13:47.370 --> 13:49.410
because I want to teach you both.

266
13:49.410 --> 13:52.395
And now you do know about both ways

267
13:52.395 --> 13:54.690
of accepting component inputs

268
13:54.690 --> 13:57.963
and both ways are important to know.