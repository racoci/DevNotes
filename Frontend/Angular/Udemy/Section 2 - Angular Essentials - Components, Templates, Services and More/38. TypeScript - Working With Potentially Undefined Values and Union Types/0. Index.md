# 38. TypeScript: Working With Potentially Undefined Values & Union Types

> Duração: `8min`

Sem Recursos

WEBVTT

1
00:00:00.300 --> 00:00:02.880
<v Maximilian>Now at this point it makes sense</v>

2
00:00:02.880 --> 00:00:05.970
to learn a bit more about TypeScript

3
00:00:05.970 --> 00:00:08.910
and writing good TypeScript code

4
00:00:08.910 --> 00:00:11.700
because we had some places here and there

5
00:00:11.700 --> 00:00:14.460
where we had to deal with TypeScript,

6
00:00:14.460 --> 00:00:18.060
like here where we assigned this string type

7
00:00:18.060 --> 00:00:21.270
or like here where we had to add this exclamation mark

8
00:00:21.270 --> 00:00:23.613
to get rid of some errors and so on.

9
00:00:24.690 --> 00:00:27.570
Now, as I mentioned before, the main thing,

10
00:00:27.570 --> 00:00:30.540
the main advantage TypeScript brings

11
00:00:30.540 --> 00:00:34.260
to the table is that it enforces strong

12
00:00:34.260 --> 00:00:37.350
and static typing, which in the end means

13
00:00:37.350 --> 00:00:41.763
you have to be clear about which type of value goes where.

14
00:00:42.780 --> 00:00:46.380
And it's because of that that we, for example, get an error

15
00:00:46.380 --> 00:00:49.170
If I were to remove this exclamation mark here

16
00:00:49.170 --> 00:00:50.820
in this getter.

17
00:00:50.820 --> 00:00:53.070
Because without that exclamation mark,

18
00:00:53.070 --> 00:00:57.330
TypeScript correctly shows us the possibility

19
00:00:57.330 --> 00:01:00.960
that find might not find a user.

20
00:01:00.960 --> 00:01:03.840
If this condition here is never met,

21
00:01:03.840 --> 00:01:07.380
if we for some reason have a selectedUserId

22
00:01:07.380 --> 00:01:09.930
that's not part of this user's array,

23
00:01:09.930 --> 00:01:14.790
find would return undefined as a value.

24
00:01:14.790 --> 00:01:18.090
And that on the other hand would cause a problem

25
00:01:18.090 --> 00:01:19.470
because we're then trying

26
00:01:19.470 --> 00:01:21.570
to access the name property

27
00:01:21.570 --> 00:01:25.740
on such a possibly undefined value,

28
00:01:25.740 --> 00:01:28.800
and that would simply crash our application.

29
00:01:28.800 --> 00:01:32.223
We would run into a runtime error here.

30
00:01:33.330 --> 00:01:36.690
That's why TypeScript is complaining about things like this.

31
00:01:36.690 --> 00:01:40.350
And that's also why in the user component,

32
00:01:40.350 --> 00:01:43.800
we had to add those exclamation marks here

33
00:01:43.800 --> 00:01:46.350
to rule out this possibility

34
00:01:46.350 --> 00:01:50.070
of possibly having an undefined value here.

35
00:01:50.070 --> 00:01:53.760
Now of course, when you add such an exclamation mark,

36
00:01:53.760 --> 00:01:57.690
you are not technically ruling out the possibility

37
00:01:57.690 --> 00:02:00.660
of getting an undefined value.

38
00:02:00.660 --> 00:02:04.680
You're just convincing TypeScript that you, the developer,

39
00:02:04.680 --> 00:02:08.550
know that you'll never have an undefined value

40
00:02:08.550 --> 00:02:10.290
in that place.

41
00:02:10.290 --> 00:02:14.460
And for these properties here, that's for example correct

42
00:02:14.460 --> 00:02:17.820
because we also set required to true,

43
00:02:17.820 --> 00:02:20.370
which means we would get an error

44
00:02:20.370 --> 00:02:22.050
during development already

45
00:02:22.050 --> 00:02:26.100
if we did forget to set one of those inputs.

46
00:02:26.100 --> 00:02:29.070
So we can therefore with confidence

47
00:02:29.070 --> 00:02:31.113
add this exclamation mark here.

48
00:02:32.700 --> 00:02:36.570
In the app component though, here when using find,

49
00:02:36.570 --> 00:02:41.070
it's not necessarily the case that we can say with certainty

50
00:02:41.070 --> 00:02:43.560
that this will never be undefined.

51
00:02:43.560 --> 00:02:48.180
We maybe can because after all, it's us writing the code

52
00:02:48.180 --> 00:02:51.960
and we know that we'll always set the selectedUserId

53
00:02:51.960 --> 00:02:55.080
to an ID that's part of all those users.

54
00:02:55.080 --> 00:02:57.630
But if we were to ever change the code

55
00:02:57.630 --> 00:03:02.630
and we for example, were to set users to a subset of users

56
00:03:02.760 --> 00:03:05.250
for whatever reason because we added filtering

57
00:03:05.250 --> 00:03:08.640
or anything like that, then we could be in a situation

58
00:03:08.640 --> 00:03:13.320
where we indeed maybe don't find a user with a selected id.

59
00:03:13.320 --> 00:03:15.330
And therefore you should be careful

60
00:03:15.330 --> 00:03:17.790
with adding marks like this.

61
00:03:17.790 --> 00:03:22.650
Instead, in situations where you maybe can't be 100% sure

62
00:03:22.650 --> 00:03:25.650
that you'll have a defined value,

63
00:03:25.650 --> 00:03:30.650
it's often better to set up some fallback code.

64
00:03:31.200 --> 00:03:35.700
For example, one way of dealing with this uncertainty here

65
00:03:35.700 --> 00:03:39.042
would be to go to this TasksComponent

66
00:03:39.042 --> 00:03:41.280
where we expect to get a name

67
00:03:41.280 --> 00:03:43.530
and to not make it required here.

68
00:03:43.530 --> 00:03:47.640
Because if we would select a user that doesn't exist,

69
00:03:47.640 --> 00:03:49.263
we wouldn't get a name.

70
00:03:50.340 --> 00:03:52.140
So we should probably remove this

71
00:03:52.140 --> 00:03:54.933
and therefore also remove this exclamation mark.

72
00:03:55.950 --> 00:03:58.350
Now with that, we of course get a complaint here,

73
00:03:58.350 --> 00:04:01.180
but now we can instead add a question mark

74
00:04:02.130 --> 00:04:05.347
and that question mark now tells TypeScript,

75
00:04:05.347 --> 00:04:07.170
"Hey, it's fine.

76
00:04:07.170 --> 00:04:10.917
This might not be set, and I am aware of that."

77
00:04:11.820 --> 00:04:13.830
Because the complaint we get without

78
00:04:13.830 --> 00:04:16.140
that question mark is just

79
00:04:16.140 --> 00:04:19.830
that TypeScript doesn't know whether this value is

80
00:04:19.830 --> 00:04:21.243
initialized or not.

81
00:04:22.350 --> 00:04:25.387
By adding this question mark, we tell TypeScript,

82
00:04:25.387 --> 00:04:28.920
"Yeah, it might not be initialized and that's okay,"

83
00:04:28.920 --> 00:04:31.533
and TypeScript does accept this.

84
00:04:32.790 --> 00:04:35.029
Now we of course just have to make sure

85
00:04:35.029 --> 00:04:39.570
that we never use this name property in a place

86
00:04:39.570 --> 00:04:41.253
where it must be set,

87
00:04:42.090 --> 00:04:45.270
but for example here where we just output it like this,

88
00:04:45.270 --> 00:04:49.650
it would be fine to do this with an undefined value.

89
00:04:49.650 --> 00:04:52.500
That would not cause a problem here.

90
00:04:52.500 --> 00:04:56.100
However, we would now have a problem in the app component

91
00:04:56.100 --> 00:04:59.490
because there, when we use the tasks component,

92
00:04:59.490 --> 00:05:01.110
we of course still try

93
00:05:01.110 --> 00:05:05.190
to access this name property on selectedUser,

94
00:05:05.190 --> 00:05:08.400
which might be undefined as I mentioned.

95
00:05:08.400 --> 00:05:09.810
You can see this here,

96
00:05:09.810 --> 00:05:12.420
this strange syntax here means

97
00:05:12.420 --> 00:05:16.950
that selectedUser is either an object that has this shape

98
00:05:16.950 --> 00:05:18.963
or it's undefined,

99
00:05:19.830 --> 00:05:22.680
and accessing the name property on undefined

100
00:05:22.680 --> 00:05:24.273
would give us a runtime error.

101
00:05:25.170 --> 00:05:27.690
And we can work around that by adding the question mark

102
00:05:27.690 --> 00:05:31.350
here as well, which is JavaScript syntax

103
00:05:31.350 --> 00:05:36.000
for saying if selectedUser is defined,

104
00:05:36.000 --> 00:05:37.380
access the name.

105
00:05:37.380 --> 00:05:42.380
If it's not, simply use undefined as a fallback value.

106
00:05:43.050 --> 00:05:45.930
So with that, we only access the name property

107
00:05:45.930 --> 00:05:47.553
if we have an object here.

108
00:05:48.930 --> 00:05:52.710
An alternative would be to write a ternary expression

109
00:05:52.710 --> 00:05:56.340
where we check if selectedUser is truthy,

110
00:05:56.340 --> 00:05:59.283
and if it is we output selectedUser.name.

111
00:06:00.120 --> 00:06:03.600
Otherwise we have some fallback value of our choice,

112
00:06:03.600 --> 00:06:06.813
like for example, an empty string like this.

113
00:06:08.130 --> 00:06:11.040
But it is important to be aware of the fact

114
00:06:11.040 --> 00:06:13.080
that when working with TypeScript,

115
00:06:13.080 --> 00:06:17.070
you have to be clear about which type of value goes where,

116
00:06:17.070 --> 00:06:18.990
and that is to your advantage

117
00:06:18.990 --> 00:06:21.990
because it can prevent unexpected runtime

118
00:06:21.990 --> 00:06:24.180
errors and problems.

119
00:06:24.180 --> 00:06:27.420
Now, there is an alternative syntax,

120
00:06:27.420 --> 00:06:31.140
an alternative to using this question mark here,

121
00:06:31.140 --> 00:06:35.370
which you should also know when working with TypeScript

122
00:06:35.370 --> 00:06:38.370
because instead of adding that question mark here,

123
00:06:38.370 --> 00:06:42.300
you could also change this type here on the right side

124
00:06:42.300 --> 00:06:45.150
of that colon, such that you make it clear

125
00:06:45.150 --> 00:06:47.670
that the accepted value types

126
00:06:47.670 --> 00:06:52.140
for name are either of type string

127
00:06:52.140 --> 00:06:54.873
or of type undefined.

128
00:06:56.400 --> 00:07:01.400
So this pipe symbol here is an important operator,

129
00:07:02.250 --> 00:07:05.880
an important symbol when working with TypeScript

130
00:07:05.880 --> 00:07:09.510
because it creates a so-called union type.

131
00:07:09.510 --> 00:07:13.200
It tells TypeScript that the type of value

132
00:07:13.200 --> 00:07:16.650
that can be stored in something in this property here

133
00:07:16.650 --> 00:07:17.670
in this case

134
00:07:17.670 --> 00:07:22.650
is either of type string or of type undefined,

135
00:07:22.650 --> 00:07:24.660
and the only value that is

136
00:07:24.660 --> 00:07:27.603
of type undefined is the value undefined.

137
00:07:28.860 --> 00:07:30.600
And that then would also work

138
00:07:30.600 --> 00:07:33.180
because with that code you would make it clear

139
00:07:33.180 --> 00:07:36.720
that it's fine if name is not defined initially,

140
00:07:36.720 --> 00:07:41.010
it may hold a string, but it can also be undefined.

141
00:07:41.010 --> 00:07:45.120
So that's an alternative to using that question mark.

142
00:07:45.120 --> 00:07:46.920
But of course the question mark

143
00:07:46.920 --> 00:07:49.200
is a bit shorter, so I'll use that.

144
00:07:49.200 --> 00:07:53.490
Nonetheless, you should know about this optional types

145
00:07:53.490 --> 00:07:56.520
feature about this union type feature

146
00:07:56.520 --> 00:07:58.800
because from time to time you do need

147
00:07:58.800 --> 00:08:01.590
to accept multiple possible values

148
00:08:01.590 --> 00:08:04.203
and now you do how you could do that.

